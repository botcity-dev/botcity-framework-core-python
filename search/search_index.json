{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome Welcome to BotCity's Framework Core Python package for RPA. Installation Latest release Using PyPI pip install botcity-framework-core Using conda-forge - Coming Soon conda install -c conda-forge botcity-framework-core Latest code pip install git + https : // github . com / botcity - dev / botcity - framework - core - python . git Important - Linux For Linux it may be necessary to install the Python 3 Tk library as well as scrot (Screenshot tool). apt install python3-tk apt install scrot","title":"Home"},{"location":"#welcome","text":"Welcome to BotCity's Framework Core Python package for RPA.","title":"Welcome"},{"location":"#installation","text":"","title":"Installation"},{"location":"#latest-release","text":"","title":"Latest release"},{"location":"#using-pypi","text":"pip install botcity-framework-core","title":"Using PyPI"},{"location":"#using-conda-forge-coming-soon","text":"conda install -c conda-forge botcity-framework-core","title":"Using conda-forge - Coming Soon"},{"location":"#latest-code","text":"pip install git + https : // github . com / botcity - dev / botcity - framework - core - python . git","title":"Latest code"},{"location":"#important-linux","text":"For Linux it may be necessary to install the Python 3 Tk library as well as scrot (Screenshot tool). apt install python3-tk apt install scrot","title":"Important - Linux"},{"location":"bot/","text":"Framework The botcity.core module contains specialized implementations aimed at Desktop automation such as DesktopBot which is described below. You are expected to implement the action method of the DesktopBot class in your Bot class. Here is a very brief example of a bot which opens the BotCity website: from botcity.core import DesktopBot class Bot ( DesktopBot ): def action ( self , execution = None ): # Opens the BotCity website. self . browse ( \"https://botcity.dev\" ) if __name__ == '__main__' : Bot . main () botcity.core.bot.DesktopBot ( BaseBot ) Base class for Desktop Bots. Users must implement the action method in their classes. Attributes: Name Type Description state State The internal state of this bot. maestro BotMaestroSDK an instance to interact with the BotMaestro server. add_image ( self , label , path ) Add an image into the state image map. Parameters: Name Type Description Default label str The image identifier required path str The path for the image on disk required Source code in core/bot.py def add_image ( self , label , path ): \"\"\" Add an image into the state image map. Args: label (str): The image identifier path (str): The path for the image on disk \"\"\" self . state . map_images [ label ] = path alt_e ( self , wait = 0 ) Press keys Alt+E Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def alt_e ( self , wait = 0 ): \"\"\" Press keys Alt+E Args: wait (int, optional): Wait interval (ms) after task \"\"\" pyautogui . hotkey ( 'alt' , 'e' , interval = 0.25 ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) alt_f ( self , wait = 0 ) Press keys Alt+F Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def alt_f ( self , wait = 0 ): \"\"\" Press keys Alt+F Args: wait (int, optional): Wait interval (ms) after task \"\"\" pyautogui . hotkey ( 'alt' , 'f' , interval = 0.25 ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) alt_f4 ( self , wait = 0 ) Press keys Alt+F4 Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def alt_f4 ( self , wait = 0 ): \"\"\" Press keys Alt+F4 Args: wait (int, optional): Wait interval (ms) after task \"\"\" pyautogui . hotkey ( 'alt' , 'f4' , interval = 0.25 ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) alt_r ( self , wait = 0 ) Press keys Alt+R Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def alt_r ( self , wait = 0 ): \"\"\" Press keys Alt+R Args: wait (int, optional): Wait interval (ms) after task \"\"\" pyautogui . hotkey ( 'alt' , 'r' , interval = 0.25 ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) alt_space ( self , wait = 0 ) Press keys Alt+Space Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def alt_space ( self , wait = 0 ): \"\"\" Press keys Alt+Space Args: wait (int, optional): Wait interval (ms) after task \"\"\" pyautogui . hotkey ( 'alt' , 'space' , interval = 0.25 ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) alt_u ( self , wait = 0 ) Press keys Alt+U Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def alt_u ( self , wait = 0 ): \"\"\" Press keys Alt+U Args: wait (int, optional): Wait interval (ms) after task \"\"\" pyautogui . hotkey ( 'alt' , 'u' , interval = 0.25 ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) backspace ( self , wait = 0 ) Press Backspace key Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def backspace ( self , wait = 0 ): \"\"\" Press Backspace key Args: wait (int, optional): Wait interval (ms) after task \"\"\" pyautogui . press ( 'backspace' ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) browse ( self , url , location = 0 ) Invoke the default browser passing an URL Parameters: Name Type Description Default url str The URL to be visited. required location int If possible, open url in a location determined by new: * 0: the same browser window (the default) * 1: a new browser window * 2: a new browser page (\"tab\") 0 Returns: Type Description bool Whether or not the request was successful Source code in core/bot.py def browse ( self , url , location = 0 ): \"\"\" Invoke the default browser passing an URL Args: url (str): The URL to be visited. location (int): If possible, open url in a location determined by new: * 0: the same browser window (the default) * 1: a new browser window * 2: a new browser page (\"tab\") Returns: bool: Whether or not the request was successful \"\"\" status = webbrowser . open ( url , location ) return status click ( self , wait_after = 300 , * , clicks = 1 , interval_between_clicks = 0 , button = 'left' ) Click on the last found element. Parameters: Name Type Description Default wait_after int Interval to wait after clicking on the element. 300 clicks int Number of times to click. Defaults to 1. 1 interval_between_clicks int The interval between clicks in ms. Defaults to 0. 0 button str One of 'left', 'right', 'middle'. Defaults to 'left' 'left' Source code in core/bot.py @only_if_element def click ( self , wait_after = config . DEFAULT_SLEEP_AFTER_ACTION , * , clicks = 1 , interval_between_clicks = 0 , button = 'left' ): \"\"\" Click on the last found element. Args: wait_after (int, optional): Interval to wait after clicking on the element. clicks (int, optional): Number of times to click. Defaults to 1. interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0. button (str, optional): One of 'left', 'right', 'middle'. Defaults to 'left' \"\"\" x , y = self . state . center () os_compat . click ( x , y , clicks = clicks , button = button , interval = interval_between_clicks / 1000.0 ) self . sleep ( wait_after ) click_at ( self , x , y ) Click at the coordinate defined by x and y Parameters: Name Type Description Default x int The X coordinate required y int The Y coordinate required Source code in core/bot.py def click_at ( self , x , y ): \"\"\" Click at the coordinate defined by x and y Args: x (int): The X coordinate y (int): The Y coordinate \"\"\" os_compat . click ( x , y ) click_on ( self , label ) Click on the element. Parameters: Name Type Description Default label str The image identifier required Source code in core/bot.py @only_if_element def click_on ( self , label ): \"\"\" Click on the element. Args: label (str): The image identifier \"\"\" x , y = self . get_element_coords_centered ( label ) os_compat . click ( x , y ) click_relative ( self , x , y , wait_after = 300 , * , clicks = 1 , interval_between_clicks = 0 , button = 'left' ) Click Relative on the last found element. Parameters: Name Type Description Default x int Horizontal offset required y int Vertical offset required wait_after int Interval to wait after clicking on the element. 300 clicks int Number of times to click. Defaults to 1. 1 interval_between_clicks int The interval between clicks in ms. Defaults to 0. 0 button str One of 'left', 'right', 'middle'. Defaults to 'left' 'left' Source code in core/bot.py @only_if_element def click_relative ( self , x , y , wait_after = config . DEFAULT_SLEEP_AFTER_ACTION , * , clicks = 1 , interval_between_clicks = 0 , button = 'left' ): \"\"\" Click Relative on the last found element. Args: x (int): Horizontal offset y (int): Vertical offset wait_after (int, optional): Interval to wait after clicking on the element. clicks (int, optional): Number of times to click. Defaults to 1. interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0. button (str, optional): One of 'left', 'right', 'middle'. Defaults to 'left' \"\"\" x = self . state . x () + x y = self . state . y () + y os_compat . click ( x , y , clicks = clicks , button = button , interval = interval_between_clicks / 1000.0 ) self . sleep ( wait_after ) control_a ( self , wait = 0 ) Press keys CTRL+A Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def control_a ( self , wait = 0 ): \"\"\" Press keys CTRL+A Args: wait (int, optional): Wait interval (ms) after task \"\"\" key = 'ctrl' if platform . system () == 'Darwin' : key = 'command' pyautogui . hotkey ( key , 'a' , interval = 0.25 ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) control_c ( self , wait = 0 ) Press keys CTRL+C Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def control_c ( self , wait = 0 ): \"\"\" Press keys CTRL+C Args: wait (int, optional): Wait interval (ms) after task \"\"\" key = 'ctrl' if platform . system () == 'Darwin' : key = 'command' pyautogui . hotkey ( key , 'c' , interval = 0.25 ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) return self . get_clipboard () control_end ( self , wait = 0 ) Press keys CTRL+End Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def control_end ( self , wait = 0 ): \"\"\" Press keys CTRL+End Args: wait (int, optional): Wait interval (ms) after task \"\"\" key = 'ctrl' if platform . system () == 'Darwin' : key = 'command' pyautogui . hotkey ( key , 'end' , interval = 0.25 ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) control_f ( self , wait = 0 ) Press keys CTRL+F Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def control_f ( self , wait = 0 ): \"\"\" Press keys CTRL+F Args: wait (int, optional): Wait interval (ms) after task \"\"\" key = 'ctrl' if platform . system () == 'Darwin' : key = 'command' pyautogui . hotkey ( key , 'f' , interval = 0.25 ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) control_home ( self , wait = 0 ) Press keys CTRL+Home Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def control_home ( self , wait = 0 ): \"\"\" Press keys CTRL+Home Args: wait (int, optional): Wait interval (ms) after task \"\"\" key = 'ctrl' if platform . system () == 'Darwin' : key = 'command' pyautogui . hotkey ( key , 'home' , interval = 0.25 ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) control_p ( self , wait = 0 ) Press keys CTRL+P Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def control_p ( self , wait = 0 ): \"\"\" Press keys CTRL+P Args: wait (int, optional): Wait interval (ms) after task \"\"\" key = 'ctrl' if platform . system () == 'Darwin' : key = 'command' pyautogui . hotkey ( key , 'p' , interval = 0.25 ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) control_r ( self , wait = 0 ) Press keys CTRL+R Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def control_r ( self , wait = 0 ): \"\"\" Press keys CTRL+R Args: wait (int, optional): Wait interval (ms) after task \"\"\" key = 'ctrl' if platform . system () == 'Darwin' : key = 'command' pyautogui . hotkey ( key , 'r' , interval = 0.25 ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) control_shift_j ( self , wait = 0 ) Press keys CTRL+Shift+J Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def control_shift_j ( self , wait = 0 ): \"\"\" Press keys CTRL+Shift+J Args: wait (int, optional): Wait interval (ms) after task \"\"\" key = 'ctrl' if platform . system () == 'Darwin' : key = 'command' pyautogui . hotkey ( key , 'shift' , 'j' , interval = 0.25 ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) control_shift_p ( self , wait = 0 ) Press keys CTRL+Shift+P Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def control_shift_p ( self , wait = 0 ): \"\"\" Press keys CTRL+Shift+P Args: wait (int, optional): Wait interval (ms) after task \"\"\" key = 'ctrl' if platform . system () == 'Darwin' : key = 'command' pyautogui . hotkey ( key , 'shift' , 'p' , interval = 0.25 ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) control_t ( self , wait = 0 ) Press keys CTRL+T Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def control_t ( self , wait = 0 ): \"\"\" Press keys CTRL+T Args: wait (int, optional): Wait interval (ms) after task \"\"\" key = 'ctrl' if platform . system () == 'Darwin' : key = 'command' pyautogui . hotkey ( key , 't' , interval = 0.25 ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) control_u ( self , wait = 0 ) Press keys CTRL+U Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def control_u ( self , wait = 0 ): \"\"\" Press keys CTRL+U Args: wait (int, optional): Wait interval (ms) after task \"\"\" key = 'ctrl' if platform . system () == 'Darwin' : key = 'command' pyautogui . hotkey ( key , 'u' , interval = 0.25 ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) control_v ( self , wait = 0 ) Press keys CTRL+V Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def control_v ( self , wait = 0 ): \"\"\" Press keys CTRL+V Args: wait (int, optional): Wait interval (ms) after task \"\"\" key = 'ctrl' if platform . system () == 'Darwin' : key = 'command' pyautogui . hotkey ( key , 'v' , interval = 0.25 ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) control_w ( self , wait = 0 ) Press keys CTRL+W Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def control_w ( self , wait = 0 ): \"\"\" Press keys CTRL+W Args: wait (int, optional): Wait interval (ms) after task \"\"\" key = 'ctrl' if platform . system () == 'Darwin' : key = 'command' pyautogui . hotkey ( key , 'w' , interval = 0.25 ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) copy_to_clipboard ( self , text , wait = 0 ) Copy content to the clipboard. Parameters: Name Type Description Default text str The text to be copied. required wait int Wait interval (ms) after task 0 Source code in core/bot.py def copy_to_clipboard ( self , text , wait = 0 ): \"\"\" Copy content to the clipboard. Args: text (str): The text to be copied. wait (int, optional): Wait interval (ms) after task \"\"\" pyperclip . copy ( text ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) delete ( self , wait = 0 ) Press Delete key Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def delete ( self , wait = 0 ): \"\"\" Press Delete key Args: wait (int, optional): Wait interval (ms) after task \"\"\" pyautogui . press ( 'delete' ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) display_size ( self ) Returns the display size in pixels. Returns: Type Description size (Tuple) The screen dimension (width and height) in pixels. Source code in core/bot.py def display_size ( self ): \"\"\" Returns the display size in pixels. Returns: size (Tuple): The screen dimension (width and height) in pixels. \"\"\" screen_size = pyautogui . size () return screen_size . width , screen_size . height double_click ( self , wait_after = 300 ) Double Click on the last found element. Parameters: Name Type Description Default wait_after int Interval to wait after clicking on the element. 300 Source code in core/bot.py @only_if_element def double_click ( self , wait_after = config . DEFAULT_SLEEP_AFTER_ACTION ): \"\"\" Double Click on the last found element. Args: wait_after (int, optional): Interval to wait after clicking on the element. \"\"\" self . click ( wait_after = wait_after , clicks = 2 ) double_click_relative ( self , x , y , interval_between_clicks = 0 , wait_after = 300 ) Double Click Relative on the last found element. Parameters: Name Type Description Default x int Horizontal offset required y int Vertical offset required interval_between_clicks int The interval between clicks in ms. Defaults to 0. 0 wait_after int Interval to wait after clicking on the element. 300 Source code in core/bot.py @only_if_element def double_click_relative ( self , x , y , interval_between_clicks = 0 , wait_after = config . DEFAULT_SLEEP_AFTER_ACTION ): \"\"\" Double Click Relative on the last found element. Args: x (int): Horizontal offset y (int): Vertical offset interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0. wait_after (int, optional): Interval to wait after clicking on the element. \"\"\" self . click_relative ( x , y , wait_after = wait_after , clicks = 2 , interval_between_clicks = interval_between_clicks ) enter ( self , wait = 0 ) Press key Enter Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def enter ( self , wait = 0 ): \"\"\" Press key Enter Args: wait (int, optional): Wait interval (ms) after task \"\"\" pyautogui . press ( 'enter' ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) execute ( self , file_path ) Invoke the system handler to open the given file. Parameters: Name Type Description Default file_path str The path for the file to be executed required Source code in core/bot.py def execute ( self , file_path ): \"\"\" Invoke the system handler to open the given file. Args: file_path (str): The path for the file to be executed \"\"\" if platform . system () == \"Windows\" : os . startfile ( file_path ) else : subprocess . Popen ( file_path . split ( \" \" )) find ( self , label , x = None , y = None , width = None , height = None , * , threshold = None , matching = 0.9 , waiting_time = 10000 , best = True , grayscale = False ) Find an element defined by label on screen until a timeout happens. Parameters: Name Type Description Default label str The image identifier required x int Search region start position x. Defaults to 0. None y int Search region start position y. Defaults to 0. None width int Search region width. Defaults to screen width. None height int Search region height. Defaults to screen height. None threshold int The threshold to be applied when doing grayscale search. Defaults to None. None matching float The matching index ranging from 0 to 1. Defaults to 0.9. 0.9 waiting_time int Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s). 10000 best bool Whether or not to keep looking until the best matching is found. Defaults to True. True grayscale bool Whether or not to convert to grayscale before searching. Defaults to False. False Returns: Type Description element (NamedTuple) The element coordinates. None if not found. Source code in core/bot.py def find ( self , label , x = None , y = None , width = None , height = None , * , threshold = None , matching = 0.9 , waiting_time = 10000 , best = True , grayscale = False ): \"\"\" Find an element defined by label on screen until a timeout happens. Args: label (str): The image identifier x (int, optional): Search region start position x. Defaults to 0. y (int, optional): Search region start position y. Defaults to 0. width (int, optional): Search region width. Defaults to screen width. height (int, optional): Search region height. Defaults to screen height. threshold (int, optional): The threshold to be applied when doing grayscale search. Defaults to None. matching (float, optional): The matching index ranging from 0 to 1. Defaults to 0.9. waiting_time (int, optional): Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s). best (bool, optional): Whether or not to keep looking until the best matching is found. Defaults to True. grayscale (bool, optional): Whether or not to convert to grayscale before searching. Defaults to False. Returns: element (NamedTuple): The element coordinates. None if not found. \"\"\" return self . find_until ( label , x = x , y = y , width = width , height = height , threshold = threshold , matching = matching , waiting_time = waiting_time , best = best , grayscale = grayscale ) find_all ( self , label , x = None , y = None , width = None , height = None , * , threshold = None , matching = 0.9 , waiting_time = 10000 , grayscale = False ) Find all elements defined by label on screen until a timeout happens. Parameters: Name Type Description Default label str The image identifier required x int Search region start position x. Defaults to 0. None y int Search region start position y. Defaults to 0. None width int Search region width. Defaults to screen width. None height int Search region height. Defaults to screen height. None threshold int The threshold to be applied when doing grayscale search. Defaults to None. None matching float The matching index ranging from 0 to 1. Defaults to 0.9. 0.9 waiting_time int Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s). 10000 grayscale bool Whether or not to convert to grayscale before searching. Defaults to False. False Returns: Type Description elements (collections.Iterable[NamedTuple]) A generator with all element coordinates fount. None if not found. Source code in core/bot.py def find_all ( self , label , x = None , y = None , width = None , height = None , * , threshold = None , matching = 0.9 , waiting_time = 10000 , grayscale = False ): \"\"\" Find all elements defined by label on screen until a timeout happens. Args: label (str): The image identifier x (int, optional): Search region start position x. Defaults to 0. y (int, optional): Search region start position y. Defaults to 0. width (int, optional): Search region width. Defaults to screen width. height (int, optional): Search region height. Defaults to screen height. threshold (int, optional): The threshold to be applied when doing grayscale search. Defaults to None. matching (float, optional): The matching index ranging from 0 to 1. Defaults to 0.9. waiting_time (int, optional): Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s). grayscale (bool, optional): Whether or not to convert to grayscale before searching. Defaults to False. Returns: elements (collections.Iterable[NamedTuple]): A generator with all element coordinates fount. None if not found. \"\"\" def deduplicate ( elems ): def find_same ( item , items ): x_start = item . left x_end = item . left + item . width y_start = item . top y_end = item . top + item . height similars = [] for itm in items : if itm == item : continue if ( itm . left >= x_start and itm . left <= x_end ) \\ and ( itm . top >= y_start and itm . top <= y_end ): similars . append ( itm ) continue return similars index = 0 while True : try : dups = find_same ( elems [ index ], elems [ index :]) for d in dups : elems . remove ( d ) index += 1 except IndexError : break return elems self . state . element = None screen_w , screen_h = pyautogui . size () x = x or 0 y = y or 0 w = width or screen_w h = height or screen_h region = ( x , y , w , h ) element_path = self . _search_image_file ( label ) if threshold : # TODO: Figure out how we should do threshold print ( 'Threshold not yet supported' ) start_time = time . time () while True : elapsed_time = ( time . time () - start_time ) * 1000 if elapsed_time > waiting_time : return None eles = pyautogui . locateAllOnScreen ( element_path , region = region , confidence = matching , grayscale = grayscale ) if not eles : continue eles = deduplicate ( list ( eles )) for ele in eles : if ele is not None : if is_retina (): ele = ele . _replace ( left = ele . left / 2.0 , top = ele . top / 2.0 ) self . state . element = ele yield ele break find_multiple ( self , labels , x = None , y = None , width = None , height = None , * , threshold = None , matching = 0.9 , waiting_time = 10000 , best = True , grayscale = False ) Find multiple elements defined by label on screen until a timeout happens. Parameters: Name Type Description Default labels list A list of image identifiers required x int Search region start position x. Defaults to 0. None y int Search region start position y. Defaults to 0. None width int Search region width. Defaults to screen width. None height int Search region height. Defaults to screen height. None threshold int The threshold to be applied when doing grayscale search. Defaults to None. None matching float The matching index ranging from 0 to 1. Defaults to 0.9. 0.9 waiting_time int Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s). 10000 best bool Whether or not to keep looking until the best matching is found. Defaults to True. True grayscale bool Whether or not to convert to grayscale before searching. Defaults to False. False Returns: Type Description results (dict) A dictionary in which the key is the label and value are the element coordinates in a NamedTuple. Source code in core/bot.py def find_multiple ( self , labels , x = None , y = None , width = None , height = None , * , threshold = None , matching = 0.9 , waiting_time = 10000 , best = True , grayscale = False ): \"\"\" Find multiple elements defined by label on screen until a timeout happens. Args: labels (list): A list of image identifiers x (int, optional): Search region start position x. Defaults to 0. y (int, optional): Search region start position y. Defaults to 0. width (int, optional): Search region width. Defaults to screen width. height (int, optional): Search region height. Defaults to screen height. threshold (int, optional): The threshold to be applied when doing grayscale search. Defaults to None. matching (float, optional): The matching index ranging from 0 to 1. Defaults to 0.9. waiting_time (int, optional): Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s). best (bool, optional): Whether or not to keep looking until the best matching is found. Defaults to True. grayscale (bool, optional): Whether or not to convert to grayscale before searching. Defaults to False. Returns: results (dict): A dictionary in which the key is the label and value are the element coordinates in a NamedTuple. \"\"\" def _to_dict ( lbs , elems ): return { k : v for k , v in zip ( lbs , elems )} screen_w , screen_h = pyautogui . size () x = x or 0 y = y or 0 w = width or screen_w h = height or screen_h region = ( x , y , w , h ) results = [ None ] * len ( labels ) paths = [ self . _search_image_file ( la ) for la in labels ] if threshold : # TODO: Figure out how we should do threshold print ( 'Threshold not yet supported' ) if not best : # TODO: Implement best=False. print ( 'Warning: Ignoring best=False for now. It will be supported in the future.' ) start_time = time . time () n_cpus = multiprocessing . cpu_count () - 1 while True : elapsed_time = ( time . time () - start_time ) * 1000 if elapsed_time > waiting_time : return _to_dict ( labels , results ) haystack = pyautogui . screenshot () helper = functools . partial ( self . _find_multiple_helper , haystack , region , matching , grayscale ) with multiprocessing . Pool ( processes = n_cpus ) as pool : results = pool . map ( helper , paths ) results = [ self . _fix_retina_element ( r ) for r in results ] if None in results : continue else : return _to_dict ( labels , results ) find_text ( self , label , x = None , y = None , width = None , height = None , * , threshold = None , matching = 0.9 , waiting_time = 10000 , best = True ) Find an element defined by label on screen until a timeout happens. Parameters: Name Type Description Default label str The image identifier required x int Search region start position x. Defaults to 0. None y int Search region start position y. Defaults to 0. None width int Search region width. Defaults to screen width. None height int Search region height. Defaults to screen height. None threshold int The threshold to be applied when doing grayscale search. Defaults to None. None matching float The matching index ranging from 0 to 1. Defaults to 0.9. 0.9 waiting_time int Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s). 10000 best bool Whether or not to keep looking until the best matching is found. Defaults to True. True Returns: Type Description element (NamedTuple) The element coordinates. None if not found. Source code in core/bot.py def find_text ( self , label , x = None , y = None , width = None , height = None , * , threshold = None , matching = 0.9 , waiting_time = 10000 , best = True ): \"\"\" Find an element defined by label on screen until a timeout happens. Args: label (str): The image identifier x (int, optional): Search region start position x. Defaults to 0. y (int, optional): Search region start position y. Defaults to 0. width (int, optional): Search region width. Defaults to screen width. height (int, optional): Search region height. Defaults to screen height. threshold (int, optional): The threshold to be applied when doing grayscale search. Defaults to None. matching (float, optional): The matching index ranging from 0 to 1. Defaults to 0.9. waiting_time (int, optional): Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s). best (bool, optional): Whether or not to keep looking until the best matching is found. Defaults to True. Returns: element (NamedTuple): The element coordinates. None if not found. \"\"\" return self . find_until ( label , x , y , width , height , threshold = threshold , matching = matching , waiting_time = waiting_time , best = best , grayscale = True ) find_until ( self , label , x = None , y = None , width = None , height = None , * , threshold = None , matching = 0.9 , waiting_time = 10000 , best = True , grayscale = False ) Find an element defined by label on screen until a timeout happens. Parameters: Name Type Description Default label str The image identifier required x int Search region start position x. Defaults to 0. None y int Search region start position y. Defaults to 0. None width int Search region width. Defaults to screen width. None height int Search region height. Defaults to screen height. None threshold int The threshold to be applied when doing grayscale search. Defaults to None. None matching float The matching index ranging from 0 to 1. Defaults to 0.9. 0.9 waiting_time int Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s). 10000 best bool Whether or not to keep looking until the best matching is found. Defaults to True. True grayscale bool Whether or not to convert to grayscale before searching. Defaults to False. False Returns: Type Description element (NamedTuple) The element coordinates. None if not found. Source code in core/bot.py def find_until ( self , label , x = None , y = None , width = None , height = None , * , threshold = None , matching = 0.9 , waiting_time = 10000 , best = True , grayscale = False ): \"\"\" Find an element defined by label on screen until a timeout happens. Args: label (str): The image identifier x (int, optional): Search region start position x. Defaults to 0. y (int, optional): Search region start position y. Defaults to 0. width (int, optional): Search region width. Defaults to screen width. height (int, optional): Search region height. Defaults to screen height. threshold (int, optional): The threshold to be applied when doing grayscale search. Defaults to None. matching (float, optional): The matching index ranging from 0 to 1. Defaults to 0.9. waiting_time (int, optional): Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s). best (bool, optional): Whether or not to keep looking until the best matching is found. Defaults to True. grayscale (bool, optional): Whether or not to convert to grayscale before searching. Defaults to False. Returns: element (NamedTuple): The element coordinates. None if not found. \"\"\" self . state . element = None screen_w , screen_h = pyautogui . size () x = x or 0 y = y or 0 w = width or screen_w h = height or screen_h region = ( x , y , w , h ) element_path = self . _search_image_file ( label ) if threshold : # TODO: Figure out how we should do threshold print ( 'Threshold not yet supported' ) if not best : # TODO: Implement best=False. print ( 'Warning: Ignoring best=False for now. It will be supported in the future.' ) start_time = time . time () while True : elapsed_time = ( time . time () - start_time ) * 1000 if elapsed_time > waiting_time : return None ele = pyautogui . locateOnScreen ( element_path , region = region , confidence = matching , grayscale = grayscale ) if ele is not None : if is_retina (): ele = ele . _replace ( left = ele . left / 2.0 , top = ele . top / 2.0 ) self . state . element = ele return ele get_clipboard ( self ) Get the current content in the clipboard. Returns: Type Description text (str) Current clipboard content Source code in core/bot.py def get_clipboard ( self ): \"\"\" Get the current content in the clipboard. Returns: text (str): Current clipboard content \"\"\" return pyperclip . paste () get_element_coords ( self , label , x = None , y = None , width = None , height = None , matching = 0.9 , best = True ) Find an element defined by label on screen and returns its coordinates. Parameters: Name Type Description Default label str The image identifier required x int X (Left) coordinate of the search area. None y int Y (Top) coordinate of the search area. None width int Width of the search area. None height int Height of the search area. None matching float Minimum score to consider a match in the element image recognition process. Defaults to 0.9. 0.9 best bool Whether or not to search for the best value. If False the method returns on the first find. Defaults to True. True Returns: Type Description coords (Tuple) A tuple containing the x and y coordinates for the element. Source code in core/bot.py def get_element_coords ( self , label , x = None , y = None , width = None , height = None , matching = 0.9 , best = True ): \"\"\" Find an element defined by label on screen and returns its coordinates. Args: label (str): The image identifier x (int, optional): X (Left) coordinate of the search area. y (int, optional): Y (Top) coordinate of the search area. width (int, optional): Width of the search area. height (int, optional): Height of the search area. matching (float, optional): Minimum score to consider a match in the element image recognition process. Defaults to 0.9. best (bool, optional): Whether or not to search for the best value. If False the method returns on the first find. Defaults to True. Returns: coords (Tuple): A tuple containing the x and y coordinates for the element. \"\"\" self . state . element = None screen_size = pyautogui . size () x = x or 0 y = y or 0 width = width or screen_size . width height = height or screen_size . height region = ( x , y , width , height ) if not best : print ( 'Warning: Ignoring best=False for now. It will be supported in the future.' ) ele = pyautogui . locateOnScreen ( self . _search_image_file ( label ), region = region , confidence = matching ) if is_retina (): ele = ele . _replace ( left = ele . left / 2.0 , top = ele . top / 2.0 ) self . state . element = ele return ele . left , ele . top get_element_coords_centered ( self , label , x = None , y = None , width = None , height = None , matching = 0.9 , best = True ) Find an element defined by label on screen and returns its centered coordinates. Parameters: Name Type Description Default label str The image identifier required x int X (Left) coordinate of the search area. None y int Y (Top) coordinate of the search area. None width int Width of the search area. None height int Height of the search area. None matching float Minimum score to consider a match in the element image recognition process. Defaults to 0.9. 0.9 best bool Whether or not to search for the best value. If False the method returns on the first find. Defaults to True. True Returns: Type Description coords (Tuple) A tuple containing the x and y coordinates for the center of the element. Source code in core/bot.py def get_element_coords_centered ( self , label , x = None , y = None , width = None , height = None , matching = 0.9 , best = True ): \"\"\" Find an element defined by label on screen and returns its centered coordinates. Args: label (str): The image identifier x (int, optional): X (Left) coordinate of the search area. y (int, optional): Y (Top) coordinate of the search area. width (int, optional): Width of the search area. height (int, optional): Height of the search area. matching (float, optional): Minimum score to consider a match in the element image recognition process. Defaults to 0.9. best (bool, optional): Whether or not to search for the best value. If False the method returns on the first find. Defaults to True. Returns: coords (Tuple): A tuple containing the x and y coordinates for the center of the element. \"\"\" self . get_element_coords ( label , x , y , width , height , matching , best ) return self . state . center () get_image_from_map ( self , label ) Return an image from teh state image map. Parameters: Name Type Description Default label str The image identifier required Returns: Type Description Image The Image object Source code in core/bot.py def get_image_from_map ( self , label ): \"\"\" Return an image from teh state image map. Args: label (str): The image identifier Returns: Image: The Image object \"\"\" path = self . state . map_images . get ( label ) if not path : raise KeyError ( 'Invalid label for image map.' ) img = Image . open ( path ) return img get_last_element ( self ) Return the last element found. Returns: Type Description element (NamedTuple) The element coordinates (left, top, width, height) Source code in core/bot.py def get_last_element ( self ): \"\"\" Return the last element found. Returns: element (NamedTuple): The element coordinates (left, top, width, height) \"\"\" return self . state . element get_last_x ( self ) Get the last X position for the mouse. Returns: Type Description x (int) The last x position for the mouse. Source code in core/bot.py def get_last_x ( self ): \"\"\" Get the last X position for the mouse. Returns: x (int): The last x position for the mouse. \"\"\" return pyautogui . position () . x get_last_y ( self ) Get the last Y position for the mouse. Returns: Type Description y (int) The last y position for the mouse. Source code in core/bot.py def get_last_y ( self ): \"\"\" Get the last Y position for the mouse. Returns: y (int): The last y position for the mouse. \"\"\" return pyautogui . position () . y get_screenshot ( self , filepath = None , region = None ) Capture a screenshot. Parameters: Name Type Description Default filepath str The filepath in which to save the screenshot. Defaults to None. None region tuple Bounding box containing left, top, width and height to crop screenshot. None Returns: Type Description Image The screenshot Image object Source code in core/bot.py def get_screenshot ( self , filepath = None , region = None ): \"\"\" Capture a screenshot. Args: filepath (str, optional): The filepath in which to save the screenshot. Defaults to None. region (tuple, optional): Bounding box containing left, top, width and height to crop screenshot. Returns: Image: The screenshot Image object \"\"\" return self . screenshot ( filepath , region ) hold_shift ( self , wait = 0 ) Hold key Shift Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def hold_shift ( self , wait = 0 ): \"\"\" Hold key Shift Args: wait (int, optional): Wait interval (ms) after task \"\"\" pyautogui . keyDown ( 'shift' ) self . sleep ( wait ) kb_type ( self , text , interval = 0 ) Type a text char by char (individual key events). Parameters: Name Type Description Default text str text to be typed. required interval int interval (ms) between each key press. Defaults to 0 0 Source code in core/bot.py def kb_type ( self , text , interval = 0 ): \"\"\" Type a text char by char (individual key events). Args: text (str): text to be typed. interval (int, optional): interval (ms) between each key press. Defaults to 0 \"\"\" pyautogui . write ( text , interval = interval / 1000.0 ) self . sleep ( config . DEFAULT_SLEEP_AFTER_ACTION ) key_end ( self , wait = 0 ) Press key End Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def key_end ( self , wait = 0 ): \"\"\" Press key End Args: wait (int, optional): Wait interval (ms) after task \"\"\" pyautogui . press ( 'end' ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) key_enter ( self , wait = 0 ) Press key Enter Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def key_enter ( self , wait = 0 ): \"\"\" Press key Enter Args: wait (int, optional): Wait interval (ms) after task \"\"\" self . enter ( wait ) key_esc ( self , wait = 0 ) Press key Esc Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def key_esc ( self , wait = 0 ): \"\"\" Press key Esc Args: wait (int, optional): Wait interval (ms) after task \"\"\" pyautogui . press ( 'esc' ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) key_right ( self , wait = 0 ) Press key Right Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def key_right ( self , wait = 0 ): \"\"\" Press key Right Args: wait (int, optional): Wait interval (ms) after task \"\"\" pyautogui . press ( 'right' ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) maximize_window ( self ) Shortcut to maximize window on Windows OS. Source code in core/bot.py def maximize_window ( self ): \"\"\" Shortcut to maximize window on Windows OS. \"\"\" self . alt_space () self . sleep ( 1000 ) pyautogui . press ( 'x' ) mouse_down ( self , wait_after = 300 , * , button = 'left' ) Holds down the requested mouse button. Parameters: Name Type Description Default wait_after int Interval to wait after clicking on the element. 300 button str One of 'left', 'right', 'middle'. Defaults to 'left' 'left' Source code in core/bot.py def mouse_down ( self , wait_after = config . DEFAULT_SLEEP_AFTER_ACTION , * , button = 'left' ): \"\"\" Holds down the requested mouse button. Args: wait_after (int, optional): Interval to wait after clicking on the element. button (str, optional): One of 'left', 'right', 'middle'. Defaults to 'left' \"\"\" pyautogui . mouseDown ( button = button ) self . sleep ( wait_after ) mouse_move ( self , x , y ) Mouse the move to the coordinate defined by x and y Parameters: Name Type Description Default x int The X coordinate required y int The Y coordinate required Source code in core/bot.py def mouse_move ( self , x , y ): \"\"\" Mouse the move to the coordinate defined by x and y Args: x (int): The X coordinate y (int): The Y coordinate \"\"\" pyautogui . moveTo ( x , y ) mouse_up ( self , wait_after = 300 , * , button = 'left' ) Releases the requested mouse button. Parameters: Name Type Description Default wait_after int Interval to wait after clicking on the element. 300 button str One of 'left', 'right', 'middle'. Defaults to 'left' 'left' Source code in core/bot.py def mouse_up ( self , wait_after = config . DEFAULT_SLEEP_AFTER_ACTION , * , button = 'left' ): \"\"\" Releases the requested mouse button. Args: wait_after (int, optional): Interval to wait after clicking on the element. button (str, optional): One of 'left', 'right', 'middle'. Defaults to 'left' \"\"\" pyautogui . mouseUp ( button = button ) self . sleep ( wait_after ) move ( self ) Move to the center position of last found item. Source code in core/bot.py @only_if_element def move ( self ): \"\"\" Move to the center position of last found item. \"\"\" x , y = self . state . center () pyautogui . moveTo ( x , y ) move_random ( self , range_x , range_y ) Move randomly along the given x, y range. Parameters: Name Type Description Default range_x int Horizontal range required range_y int Vertical range required Source code in core/bot.py def move_random ( self , range_x , range_y ): \"\"\" Move randomly along the given x, y range. Args: range_x (int): Horizontal range range_y (int): Vertical range \"\"\" x = int ( random . random () * range_x ) y = int ( random . random () * range_y ) pyautogui . moveTo ( x , y ) move_relative ( self , x , y ) Move the mouse relative to its current position. Parameters: Name Type Description Default x int Horizontal offset required y int Vertical offset required Source code in core/bot.py def move_relative ( self , x , y ): \"\"\" Move the mouse relative to its current position. Args: x (int): Horizontal offset y (int): Vertical offset \"\"\" x = self . get_last_x () + x y = self . get_last_y () + y pyautogui . moveTo ( x , y ) page_down ( self , wait = 0 ) Press Page Down key Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def page_down ( self , wait = 0 ): \"\"\" Press Page Down key Args: wait (int, optional): Wait interval (ms) after task \"\"\" pyautogui . press ( 'pagedown' ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) page_up ( self , wait = 0 ) Press Page Up key Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def page_up ( self , wait = 0 ): \"\"\" Press Page Up key Args: wait (int, optional): Wait interval (ms) after task \"\"\" pyautogui . press ( 'pageup' ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) paste ( self , text = None , wait = 0 ) Paste content from the clipboard. Parameters: Name Type Description Default text str The text to be pasted. Defaults to None None wait int Wait interval (ms) after task 0 Source code in core/bot.py def paste ( self , text = None , wait = 0 ): \"\"\" Paste content from the clipboard. Args: text (str, optional): The text to be pasted. Defaults to None wait (int, optional): Wait interval (ms) after task \"\"\" if text : pyperclip . copy ( text ) self . sleep ( 500 ) self . control_v () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) release_shift ( self ) Release key Shift. This method needs to be invoked after holding Shift or similar. Source code in core/bot.py def release_shift ( self ): \"\"\" Release key Shift. This method needs to be invoked after holding Shift or similar. \"\"\" pyautogui . keyUp ( 'shift' ) right_click ( self , wait_after = 300 , * , clicks = 1 , interval_between_clicks = 0 ) Right click on the last found element. Parameters: Name Type Description Default wait_after int Interval to wait after clicking on the element. 300 clicks int Number of times to click. Defaults to 1. 1 interval_between_clicks int The interval between clicks in ms. Defaults to 0. 0 Source code in core/bot.py @only_if_element def right_click ( self , wait_after = config . DEFAULT_SLEEP_AFTER_ACTION , * , clicks = 1 , interval_between_clicks = 0 ): \"\"\" Right click on the last found element. Args: wait_after (int, optional): Interval to wait after clicking on the element. clicks (int, optional): Number of times to click. Defaults to 1. interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0. \"\"\" x , y = self . state . center () os_compat . click ( x , y , clicks = clicks , button = 'right' , interval = interval_between_clicks / 1000.0 ) self . sleep ( wait_after ) right_click_at ( self , x , y ) Right click at the coordinate defined by x and y Parameters: Name Type Description Default x int The X coordinate required y int The Y coordinate required Source code in core/bot.py def right_click_at ( self , x , y ): \"\"\" Right click at the coordinate defined by x and y Args: x (int): The X coordinate y (int): The Y coordinate \"\"\" os_compat . click ( x , y , button = 'right' ) right_click_relative ( self , x , y , interval_between_clicks = 0 , wait_after = 300 ) Right Click Relative on the last found element. Parameters: Name Type Description Default x int Horizontal offset required y int Vertical offset required interval_between_clicks int The interval between clicks in ms. Defaults to 0. 0 wait_after int Interval to wait after clicking on the element. 300 Source code in core/bot.py @only_if_element def right_click_relative ( self , x , y , interval_between_clicks = 0 , wait_after = config . DEFAULT_SLEEP_AFTER_ACTION ): \"\"\" Right Click Relative on the last found element. Args: x (int): Horizontal offset y (int): Vertical offset interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0. wait_after (int, optional): Interval to wait after clicking on the element. \"\"\" x = self . state . x () + x y = self . state . y () + y self . click_relative ( x , y , wait_after = wait_after , clicks = 3 , interval_between_clicks = interval_between_clicks , button = 'right' ) save_screenshot ( self , path ) Saves a screenshot in a given path. Parameters: Name Type Description Default path str The filepath in which to save the screenshot required Source code in core/bot.py def save_screenshot ( self , path ): \"\"\" Saves a screenshot in a given path. Args: path (str): The filepath in which to save the screenshot \"\"\" pyautogui . screenshot ( path ) screen_cut ( self , x , y , width = None , height = None ) Capture a screenshot from a region of the screen. Parameters: Name Type Description Default x int region start position x required y int region start position y required width int region width None height int region height None Returns: Type Description Image The screenshot Image object Source code in core/bot.py def screen_cut ( self , x , y , width = None , height = None ): \"\"\" Capture a screenshot from a region of the screen. Args: x (int): region start position x y (int): region start position y width (int): region width height (int): region height Returns: Image: The screenshot Image object \"\"\" screen_size = pyautogui . size () x = x or 0 y = y or 0 width = width or screen_size . width height = height or screen_size . height img = pyautogui . screenshot ( region = ( x , y , width , height )) return img screenshot ( self , filepath = None , region = None ) Capture a screenshot. Parameters: Name Type Description Default filepath str The filepath in which to save the screenshot. Defaults to None. None region tuple Bounding box containing left, top, width and height to crop screenshot. None Returns: Type Description Image The screenshot Image object Source code in core/bot.py def screenshot ( self , filepath = None , region = None ): \"\"\" Capture a screenshot. Args: filepath (str, optional): The filepath in which to save the screenshot. Defaults to None. region (tuple, optional): Bounding box containing left, top, width and height to crop screenshot. Returns: Image: The screenshot Image object \"\"\" img = pyautogui . screenshot ( filepath , region ) return img scroll_down ( self , clicks ) Scroll Down n clicks Parameters: Name Type Description Default clicks int Number of times to scroll down. required Source code in core/bot.py def scroll_down ( self , clicks ): \"\"\" Scroll Down n clicks Args: clicks (int): Number of times to scroll down. \"\"\" pyautogui . scroll ( - 1 * clicks ) scroll_up ( self , clicks ) Scroll Up n clicks Parameters: Name Type Description Default clicks int Number of times to scroll up. required Source code in core/bot.py def scroll_up ( self , clicks ): \"\"\" Scroll Up n clicks Args: clicks (int): Number of times to scroll up. \"\"\" pyautogui . scroll ( clicks ) shift_tab ( self , wait = 0 ) Press keys Shift+Tab Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def shift_tab ( self , wait = 0 ): \"\"\" Press keys Shift+Tab Args: wait (int, optional): Wait interval (ms) after task \"\"\" pyautogui . hotkey ( 'shift' , 'tab' , interval = 0.25 ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) sleep ( self , interval ) Wait / Sleep for a given interval. Parameters: Name Type Description Default interval int Interval in milliseconds required Source code in core/bot.py def sleep ( self , interval ): \"\"\" Wait / Sleep for a given interval. Args: interval (int): Interval in milliseconds \"\"\" self . wait ( interval ) space ( self , wait = 0 ) Press Space key Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def space ( self , wait = 0 ): \"\"\" Press Space key Args: wait (int, optional): Wait interval (ms) after task \"\"\" pyautogui . press ( 'space' ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) tab ( self , wait = 0 ) Press key Tab Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def tab ( self , wait = 0 ): \"\"\" Press key Tab Args: wait (int, optional): Wait interval (ms) after task \"\"\" pyautogui . press ( 'tab' ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) triple_click ( self , wait_after = 300 ) Triple Click on the last found element. Parameters: Name Type Description Default wait_after int Interval to wait after clicking on the element. 300 Source code in core/bot.py @only_if_element def triple_click ( self , wait_after = config . DEFAULT_SLEEP_AFTER_ACTION ): \"\"\" Triple Click on the last found element. Args: wait_after (int, optional): Interval to wait after clicking on the element. \"\"\" self . click ( wait_after = wait_after , clicks = 3 ) triple_click_relative ( self , x , y , interval_between_clicks = 0 , wait_after = 300 ) Triple Click Relative on the last found element. Parameters: Name Type Description Default x int Horizontal offset required y int Vertical offset required interval_between_clicks int The interval between clicks in ms. Defaults to 0. 0 wait_after int Interval to wait after clicking on the element. 300 Source code in core/bot.py @only_if_element def triple_click_relative ( self , x , y , interval_between_clicks = 0 , wait_after = config . DEFAULT_SLEEP_AFTER_ACTION ): \"\"\" Triple Click Relative on the last found element. Args: x (int): Horizontal offset y (int): Vertical offset interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0. wait_after (int, optional): Interval to wait after clicking on the element. \"\"\" self . click_relative ( x , y , wait_after = wait_after , clicks = 3 , interval_between_clicks = interval_between_clicks ) type_down ( self , wait = 0 ) Press Down key Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def type_down ( self , wait = 0 ): \"\"\" Press Down key Args: wait (int, optional): Wait interval (ms) after task \"\"\" pyautogui . press ( 'down' ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) type_key ( self , text , interval = 0 ) Type a text char by char (individual key events). Parameters: Name Type Description Default text str text to be typed. required interval int interval (ms) between each key press. Defaults to 0 0 Source code in core/bot.py def type_key ( self , text , interval = 0 ): \"\"\" Type a text char by char (individual key events). Args: text (str): text to be typed. interval (int, optional): interval (ms) between each key press. Defaults to 0 \"\"\" self . kb_type ( text = text , interval = interval / 1000.0 ) type_keys ( self , keys ) Press a sequence of keys. Hold the keys in the specific order and releases them. Parameters: Name Type Description Default keys list List of keys to be pressed required Source code in core/bot.py def type_keys ( self , keys ): \"\"\" Press a sequence of keys. Hold the keys in the specific order and releases them. Args: keys (list): List of keys to be pressed \"\"\" self . type_keys_with_interval ( 100 , keys ) type_keys_with_interval ( self , interval , keys ) Press a sequence of keys. Hold the keys in the specific order and releases them. Parameters: Name Type Description Default interval int Interval (ms) in which to press and release keys required keys list List of keys to be pressed required Source code in core/bot.py def type_keys_with_interval ( self , interval , keys ): \"\"\" Press a sequence of keys. Hold the keys in the specific order and releases them. Args: interval (int): Interval (ms) in which to press and release keys keys (list): List of keys to be pressed \"\"\" pyautogui . hotkey ( * keys , interval = interval / 1000.0 ) type_left ( self , wait = 0 ) Press Left key Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def type_left ( self , wait = 0 ): \"\"\" Press Left key Args: wait (int, optional): Wait interval (ms) after task \"\"\" pyautogui . press ( 'left' ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) type_right ( self , wait = 0 ) Press Right key Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def type_right ( self , wait = 0 ): \"\"\" Press Right key Args: wait (int, optional): Wait interval (ms) after task \"\"\" pyautogui . press ( 'right' ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) type_up ( self , wait = 0 ) Press Up key Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def type_up ( self , wait = 0 ): \"\"\" Press Up key Args: wait (int, optional): Wait interval (ms) after task \"\"\" pyautogui . press ( 'up' ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) type_windows ( self , wait = 0 ) Press Win logo key Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def type_windows ( self , wait = 0 ): \"\"\" Press Win logo key Args: wait (int, optional): Wait interval (ms) after task \"\"\" pyautogui . press ( 'win' ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) wait ( self , interval ) Wait / Sleep for a given interval. Parameters: Name Type Description Default interval int Interval in milliseconds required Source code in core/bot.py def wait ( self , interval ): \"\"\" Wait / Sleep for a given interval. Args: interval (int): Interval in milliseconds \"\"\" time . sleep ( interval / 1000.0 ) wait_for_file ( self , path , timeout = 10000 ) Invoke the system handler to open the given file. Parameters: Name Type Description Default path str The path for the file to be executed required timeout int Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s). 10000 Returns status (bool): Whether or not the file was available before the timeout Source code in core/bot.py def wait_for_file ( self , path , timeout = 10000 ): \"\"\" Invoke the system handler to open the given file. Args: path (str): The path for the file to be executed timeout (int, optional): Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s). Returns status (bool): Whether or not the file was available before the timeout \"\"\" start_time = time . time () while True : elapsed_time = ( time . time () - start_time ) * 1000 if elapsed_time > timeout : return False if os . path . isfile ( path ) and os . access ( path , os . R_OK ): return True self . sleep ( config . DEFAULT_SLEEP_AFTER_ACTION )","title":"Framework"},{"location":"bot/#framework","text":"The botcity.core module contains specialized implementations aimed at Desktop automation such as DesktopBot which is described below. You are expected to implement the action method of the DesktopBot class in your Bot class. Here is a very brief example of a bot which opens the BotCity website: from botcity.core import DesktopBot class Bot ( DesktopBot ): def action ( self , execution = None ): # Opens the BotCity website. self . browse ( \"https://botcity.dev\" ) if __name__ == '__main__' : Bot . main ()","title":"Framework"},{"location":"bot/#botcity.core.bot.DesktopBot","text":"Base class for Desktop Bots. Users must implement the action method in their classes. Attributes: Name Type Description state State The internal state of this bot. maestro BotMaestroSDK an instance to interact with the BotMaestro server.","title":"DesktopBot"},{"location":"bot/#botcity.core.bot.DesktopBot.add_image","text":"Add an image into the state image map. Parameters: Name Type Description Default label str The image identifier required path str The path for the image on disk required Source code in core/bot.py def add_image ( self , label , path ): \"\"\" Add an image into the state image map. Args: label (str): The image identifier path (str): The path for the image on disk \"\"\" self . state . map_images [ label ] = path","title":"add_image()"},{"location":"bot/#botcity.core.bot.DesktopBot.alt_e","text":"Press keys Alt+E Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def alt_e ( self , wait = 0 ): \"\"\" Press keys Alt+E Args: wait (int, optional): Wait interval (ms) after task \"\"\" pyautogui . hotkey ( 'alt' , 'e' , interval = 0.25 ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay )","title":"alt_e()"},{"location":"bot/#botcity.core.bot.DesktopBot.alt_f","text":"Press keys Alt+F Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def alt_f ( self , wait = 0 ): \"\"\" Press keys Alt+F Args: wait (int, optional): Wait interval (ms) after task \"\"\" pyautogui . hotkey ( 'alt' , 'f' , interval = 0.25 ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay )","title":"alt_f()"},{"location":"bot/#botcity.core.bot.DesktopBot.alt_f4","text":"Press keys Alt+F4 Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def alt_f4 ( self , wait = 0 ): \"\"\" Press keys Alt+F4 Args: wait (int, optional): Wait interval (ms) after task \"\"\" pyautogui . hotkey ( 'alt' , 'f4' , interval = 0.25 ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay )","title":"alt_f4()"},{"location":"bot/#botcity.core.bot.DesktopBot.alt_r","text":"Press keys Alt+R Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def alt_r ( self , wait = 0 ): \"\"\" Press keys Alt+R Args: wait (int, optional): Wait interval (ms) after task \"\"\" pyautogui . hotkey ( 'alt' , 'r' , interval = 0.25 ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay )","title":"alt_r()"},{"location":"bot/#botcity.core.bot.DesktopBot.alt_space","text":"Press keys Alt+Space Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def alt_space ( self , wait = 0 ): \"\"\" Press keys Alt+Space Args: wait (int, optional): Wait interval (ms) after task \"\"\" pyautogui . hotkey ( 'alt' , 'space' , interval = 0.25 ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay )","title":"alt_space()"},{"location":"bot/#botcity.core.bot.DesktopBot.alt_u","text":"Press keys Alt+U Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def alt_u ( self , wait = 0 ): \"\"\" Press keys Alt+U Args: wait (int, optional): Wait interval (ms) after task \"\"\" pyautogui . hotkey ( 'alt' , 'u' , interval = 0.25 ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay )","title":"alt_u()"},{"location":"bot/#botcity.core.bot.DesktopBot.backspace","text":"Press Backspace key Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def backspace ( self , wait = 0 ): \"\"\" Press Backspace key Args: wait (int, optional): Wait interval (ms) after task \"\"\" pyautogui . press ( 'backspace' ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay )","title":"backspace()"},{"location":"bot/#botcity.core.bot.DesktopBot.browse","text":"Invoke the default browser passing an URL Parameters: Name Type Description Default url str The URL to be visited. required location int If possible, open url in a location determined by new: * 0: the same browser window (the default) * 1: a new browser window * 2: a new browser page (\"tab\") 0 Returns: Type Description bool Whether or not the request was successful Source code in core/bot.py def browse ( self , url , location = 0 ): \"\"\" Invoke the default browser passing an URL Args: url (str): The URL to be visited. location (int): If possible, open url in a location determined by new: * 0: the same browser window (the default) * 1: a new browser window * 2: a new browser page (\"tab\") Returns: bool: Whether or not the request was successful \"\"\" status = webbrowser . open ( url , location ) return status","title":"browse()"},{"location":"bot/#botcity.core.bot.DesktopBot.click","text":"Click on the last found element. Parameters: Name Type Description Default wait_after int Interval to wait after clicking on the element. 300 clicks int Number of times to click. Defaults to 1. 1 interval_between_clicks int The interval between clicks in ms. Defaults to 0. 0 button str One of 'left', 'right', 'middle'. Defaults to 'left' 'left' Source code in core/bot.py @only_if_element def click ( self , wait_after = config . DEFAULT_SLEEP_AFTER_ACTION , * , clicks = 1 , interval_between_clicks = 0 , button = 'left' ): \"\"\" Click on the last found element. Args: wait_after (int, optional): Interval to wait after clicking on the element. clicks (int, optional): Number of times to click. Defaults to 1. interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0. button (str, optional): One of 'left', 'right', 'middle'. Defaults to 'left' \"\"\" x , y = self . state . center () os_compat . click ( x , y , clicks = clicks , button = button , interval = interval_between_clicks / 1000.0 ) self . sleep ( wait_after )","title":"click()"},{"location":"bot/#botcity.core.bot.DesktopBot.click_at","text":"Click at the coordinate defined by x and y Parameters: Name Type Description Default x int The X coordinate required y int The Y coordinate required Source code in core/bot.py def click_at ( self , x , y ): \"\"\" Click at the coordinate defined by x and y Args: x (int): The X coordinate y (int): The Y coordinate \"\"\" os_compat . click ( x , y )","title":"click_at()"},{"location":"bot/#botcity.core.bot.DesktopBot.click_on","text":"Click on the element. Parameters: Name Type Description Default label str The image identifier required Source code in core/bot.py @only_if_element def click_on ( self , label ): \"\"\" Click on the element. Args: label (str): The image identifier \"\"\" x , y = self . get_element_coords_centered ( label ) os_compat . click ( x , y )","title":"click_on()"},{"location":"bot/#botcity.core.bot.DesktopBot.click_relative","text":"Click Relative on the last found element. Parameters: Name Type Description Default x int Horizontal offset required y int Vertical offset required wait_after int Interval to wait after clicking on the element. 300 clicks int Number of times to click. Defaults to 1. 1 interval_between_clicks int The interval between clicks in ms. Defaults to 0. 0 button str One of 'left', 'right', 'middle'. Defaults to 'left' 'left' Source code in core/bot.py @only_if_element def click_relative ( self , x , y , wait_after = config . DEFAULT_SLEEP_AFTER_ACTION , * , clicks = 1 , interval_between_clicks = 0 , button = 'left' ): \"\"\" Click Relative on the last found element. Args: x (int): Horizontal offset y (int): Vertical offset wait_after (int, optional): Interval to wait after clicking on the element. clicks (int, optional): Number of times to click. Defaults to 1. interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0. button (str, optional): One of 'left', 'right', 'middle'. Defaults to 'left' \"\"\" x = self . state . x () + x y = self . state . y () + y os_compat . click ( x , y , clicks = clicks , button = button , interval = interval_between_clicks / 1000.0 ) self . sleep ( wait_after )","title":"click_relative()"},{"location":"bot/#botcity.core.bot.DesktopBot.control_a","text":"Press keys CTRL+A Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def control_a ( self , wait = 0 ): \"\"\" Press keys CTRL+A Args: wait (int, optional): Wait interval (ms) after task \"\"\" key = 'ctrl' if platform . system () == 'Darwin' : key = 'command' pyautogui . hotkey ( key , 'a' , interval = 0.25 ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay )","title":"control_a()"},{"location":"bot/#botcity.core.bot.DesktopBot.control_c","text":"Press keys CTRL+C Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def control_c ( self , wait = 0 ): \"\"\" Press keys CTRL+C Args: wait (int, optional): Wait interval (ms) after task \"\"\" key = 'ctrl' if platform . system () == 'Darwin' : key = 'command' pyautogui . hotkey ( key , 'c' , interval = 0.25 ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay ) return self . get_clipboard ()","title":"control_c()"},{"location":"bot/#botcity.core.bot.DesktopBot.control_end","text":"Press keys CTRL+End Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def control_end ( self , wait = 0 ): \"\"\" Press keys CTRL+End Args: wait (int, optional): Wait interval (ms) after task \"\"\" key = 'ctrl' if platform . system () == 'Darwin' : key = 'command' pyautogui . hotkey ( key , 'end' , interval = 0.25 ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay )","title":"control_end()"},{"location":"bot/#botcity.core.bot.DesktopBot.control_f","text":"Press keys CTRL+F Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def control_f ( self , wait = 0 ): \"\"\" Press keys CTRL+F Args: wait (int, optional): Wait interval (ms) after task \"\"\" key = 'ctrl' if platform . system () == 'Darwin' : key = 'command' pyautogui . hotkey ( key , 'f' , interval = 0.25 ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay )","title":"control_f()"},{"location":"bot/#botcity.core.bot.DesktopBot.control_home","text":"Press keys CTRL+Home Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def control_home ( self , wait = 0 ): \"\"\" Press keys CTRL+Home Args: wait (int, optional): Wait interval (ms) after task \"\"\" key = 'ctrl' if platform . system () == 'Darwin' : key = 'command' pyautogui . hotkey ( key , 'home' , interval = 0.25 ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay )","title":"control_home()"},{"location":"bot/#botcity.core.bot.DesktopBot.control_p","text":"Press keys CTRL+P Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def control_p ( self , wait = 0 ): \"\"\" Press keys CTRL+P Args: wait (int, optional): Wait interval (ms) after task \"\"\" key = 'ctrl' if platform . system () == 'Darwin' : key = 'command' pyautogui . hotkey ( key , 'p' , interval = 0.25 ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay )","title":"control_p()"},{"location":"bot/#botcity.core.bot.DesktopBot.control_r","text":"Press keys CTRL+R Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def control_r ( self , wait = 0 ): \"\"\" Press keys CTRL+R Args: wait (int, optional): Wait interval (ms) after task \"\"\" key = 'ctrl' if platform . system () == 'Darwin' : key = 'command' pyautogui . hotkey ( key , 'r' , interval = 0.25 ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay )","title":"control_r()"},{"location":"bot/#botcity.core.bot.DesktopBot.control_shift_j","text":"Press keys CTRL+Shift+J Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def control_shift_j ( self , wait = 0 ): \"\"\" Press keys CTRL+Shift+J Args: wait (int, optional): Wait interval (ms) after task \"\"\" key = 'ctrl' if platform . system () == 'Darwin' : key = 'command' pyautogui . hotkey ( key , 'shift' , 'j' , interval = 0.25 ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay )","title":"control_shift_j()"},{"location":"bot/#botcity.core.bot.DesktopBot.control_shift_p","text":"Press keys CTRL+Shift+P Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def control_shift_p ( self , wait = 0 ): \"\"\" Press keys CTRL+Shift+P Args: wait (int, optional): Wait interval (ms) after task \"\"\" key = 'ctrl' if platform . system () == 'Darwin' : key = 'command' pyautogui . hotkey ( key , 'shift' , 'p' , interval = 0.25 ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay )","title":"control_shift_p()"},{"location":"bot/#botcity.core.bot.DesktopBot.control_t","text":"Press keys CTRL+T Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def control_t ( self , wait = 0 ): \"\"\" Press keys CTRL+T Args: wait (int, optional): Wait interval (ms) after task \"\"\" key = 'ctrl' if platform . system () == 'Darwin' : key = 'command' pyautogui . hotkey ( key , 't' , interval = 0.25 ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay )","title":"control_t()"},{"location":"bot/#botcity.core.bot.DesktopBot.control_u","text":"Press keys CTRL+U Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def control_u ( self , wait = 0 ): \"\"\" Press keys CTRL+U Args: wait (int, optional): Wait interval (ms) after task \"\"\" key = 'ctrl' if platform . system () == 'Darwin' : key = 'command' pyautogui . hotkey ( key , 'u' , interval = 0.25 ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay )","title":"control_u()"},{"location":"bot/#botcity.core.bot.DesktopBot.control_v","text":"Press keys CTRL+V Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def control_v ( self , wait = 0 ): \"\"\" Press keys CTRL+V Args: wait (int, optional): Wait interval (ms) after task \"\"\" key = 'ctrl' if platform . system () == 'Darwin' : key = 'command' pyautogui . hotkey ( key , 'v' , interval = 0.25 ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay )","title":"control_v()"},{"location":"bot/#botcity.core.bot.DesktopBot.control_w","text":"Press keys CTRL+W Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def control_w ( self , wait = 0 ): \"\"\" Press keys CTRL+W Args: wait (int, optional): Wait interval (ms) after task \"\"\" key = 'ctrl' if platform . system () == 'Darwin' : key = 'command' pyautogui . hotkey ( key , 'w' , interval = 0.25 ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay )","title":"control_w()"},{"location":"bot/#botcity.core.bot.DesktopBot.copy_to_clipboard","text":"Copy content to the clipboard. Parameters: Name Type Description Default text str The text to be copied. required wait int Wait interval (ms) after task 0 Source code in core/bot.py def copy_to_clipboard ( self , text , wait = 0 ): \"\"\" Copy content to the clipboard. Args: text (str): The text to be copied. wait (int, optional): Wait interval (ms) after task \"\"\" pyperclip . copy ( text ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay )","title":"copy_to_clipboard()"},{"location":"bot/#botcity.core.bot.DesktopBot.delete","text":"Press Delete key Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def delete ( self , wait = 0 ): \"\"\" Press Delete key Args: wait (int, optional): Wait interval (ms) after task \"\"\" pyautogui . press ( 'delete' ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay )","title":"delete()"},{"location":"bot/#botcity.core.bot.DesktopBot.display_size","text":"Returns the display size in pixels. Returns: Type Description size (Tuple) The screen dimension (width and height) in pixels. Source code in core/bot.py def display_size ( self ): \"\"\" Returns the display size in pixels. Returns: size (Tuple): The screen dimension (width and height) in pixels. \"\"\" screen_size = pyautogui . size () return screen_size . width , screen_size . height","title":"display_size()"},{"location":"bot/#botcity.core.bot.DesktopBot.double_click","text":"Double Click on the last found element. Parameters: Name Type Description Default wait_after int Interval to wait after clicking on the element. 300 Source code in core/bot.py @only_if_element def double_click ( self , wait_after = config . DEFAULT_SLEEP_AFTER_ACTION ): \"\"\" Double Click on the last found element. Args: wait_after (int, optional): Interval to wait after clicking on the element. \"\"\" self . click ( wait_after = wait_after , clicks = 2 )","title":"double_click()"},{"location":"bot/#botcity.core.bot.DesktopBot.double_click_relative","text":"Double Click Relative on the last found element. Parameters: Name Type Description Default x int Horizontal offset required y int Vertical offset required interval_between_clicks int The interval between clicks in ms. Defaults to 0. 0 wait_after int Interval to wait after clicking on the element. 300 Source code in core/bot.py @only_if_element def double_click_relative ( self , x , y , interval_between_clicks = 0 , wait_after = config . DEFAULT_SLEEP_AFTER_ACTION ): \"\"\" Double Click Relative on the last found element. Args: x (int): Horizontal offset y (int): Vertical offset interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0. wait_after (int, optional): Interval to wait after clicking on the element. \"\"\" self . click_relative ( x , y , wait_after = wait_after , clicks = 2 , interval_between_clicks = interval_between_clicks )","title":"double_click_relative()"},{"location":"bot/#botcity.core.bot.DesktopBot.enter","text":"Press key Enter Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def enter ( self , wait = 0 ): \"\"\" Press key Enter Args: wait (int, optional): Wait interval (ms) after task \"\"\" pyautogui . press ( 'enter' ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay )","title":"enter()"},{"location":"bot/#botcity.core.bot.DesktopBot.execute","text":"Invoke the system handler to open the given file. Parameters: Name Type Description Default file_path str The path for the file to be executed required Source code in core/bot.py def execute ( self , file_path ): \"\"\" Invoke the system handler to open the given file. Args: file_path (str): The path for the file to be executed \"\"\" if platform . system () == \"Windows\" : os . startfile ( file_path ) else : subprocess . Popen ( file_path . split ( \" \" ))","title":"execute()"},{"location":"bot/#botcity.core.bot.DesktopBot.find","text":"Find an element defined by label on screen until a timeout happens. Parameters: Name Type Description Default label str The image identifier required x int Search region start position x. Defaults to 0. None y int Search region start position y. Defaults to 0. None width int Search region width. Defaults to screen width. None height int Search region height. Defaults to screen height. None threshold int The threshold to be applied when doing grayscale search. Defaults to None. None matching float The matching index ranging from 0 to 1. Defaults to 0.9. 0.9 waiting_time int Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s). 10000 best bool Whether or not to keep looking until the best matching is found. Defaults to True. True grayscale bool Whether or not to convert to grayscale before searching. Defaults to False. False Returns: Type Description element (NamedTuple) The element coordinates. None if not found. Source code in core/bot.py def find ( self , label , x = None , y = None , width = None , height = None , * , threshold = None , matching = 0.9 , waiting_time = 10000 , best = True , grayscale = False ): \"\"\" Find an element defined by label on screen until a timeout happens. Args: label (str): The image identifier x (int, optional): Search region start position x. Defaults to 0. y (int, optional): Search region start position y. Defaults to 0. width (int, optional): Search region width. Defaults to screen width. height (int, optional): Search region height. Defaults to screen height. threshold (int, optional): The threshold to be applied when doing grayscale search. Defaults to None. matching (float, optional): The matching index ranging from 0 to 1. Defaults to 0.9. waiting_time (int, optional): Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s). best (bool, optional): Whether or not to keep looking until the best matching is found. Defaults to True. grayscale (bool, optional): Whether or not to convert to grayscale before searching. Defaults to False. Returns: element (NamedTuple): The element coordinates. None if not found. \"\"\" return self . find_until ( label , x = x , y = y , width = width , height = height , threshold = threshold , matching = matching , waiting_time = waiting_time , best = best , grayscale = grayscale )","title":"find()"},{"location":"bot/#botcity.core.bot.DesktopBot.find_all","text":"Find all elements defined by label on screen until a timeout happens. Parameters: Name Type Description Default label str The image identifier required x int Search region start position x. Defaults to 0. None y int Search region start position y. Defaults to 0. None width int Search region width. Defaults to screen width. None height int Search region height. Defaults to screen height. None threshold int The threshold to be applied when doing grayscale search. Defaults to None. None matching float The matching index ranging from 0 to 1. Defaults to 0.9. 0.9 waiting_time int Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s). 10000 grayscale bool Whether or not to convert to grayscale before searching. Defaults to False. False Returns: Type Description elements (collections.Iterable[NamedTuple]) A generator with all element coordinates fount. None if not found. Source code in core/bot.py def find_all ( self , label , x = None , y = None , width = None , height = None , * , threshold = None , matching = 0.9 , waiting_time = 10000 , grayscale = False ): \"\"\" Find all elements defined by label on screen until a timeout happens. Args: label (str): The image identifier x (int, optional): Search region start position x. Defaults to 0. y (int, optional): Search region start position y. Defaults to 0. width (int, optional): Search region width. Defaults to screen width. height (int, optional): Search region height. Defaults to screen height. threshold (int, optional): The threshold to be applied when doing grayscale search. Defaults to None. matching (float, optional): The matching index ranging from 0 to 1. Defaults to 0.9. waiting_time (int, optional): Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s). grayscale (bool, optional): Whether or not to convert to grayscale before searching. Defaults to False. Returns: elements (collections.Iterable[NamedTuple]): A generator with all element coordinates fount. None if not found. \"\"\" def deduplicate ( elems ): def find_same ( item , items ): x_start = item . left x_end = item . left + item . width y_start = item . top y_end = item . top + item . height similars = [] for itm in items : if itm == item : continue if ( itm . left >= x_start and itm . left <= x_end ) \\ and ( itm . top >= y_start and itm . top <= y_end ): similars . append ( itm ) continue return similars index = 0 while True : try : dups = find_same ( elems [ index ], elems [ index :]) for d in dups : elems . remove ( d ) index += 1 except IndexError : break return elems self . state . element = None screen_w , screen_h = pyautogui . size () x = x or 0 y = y or 0 w = width or screen_w h = height or screen_h region = ( x , y , w , h ) element_path = self . _search_image_file ( label ) if threshold : # TODO: Figure out how we should do threshold print ( 'Threshold not yet supported' ) start_time = time . time () while True : elapsed_time = ( time . time () - start_time ) * 1000 if elapsed_time > waiting_time : return None eles = pyautogui . locateAllOnScreen ( element_path , region = region , confidence = matching , grayscale = grayscale ) if not eles : continue eles = deduplicate ( list ( eles )) for ele in eles : if ele is not None : if is_retina (): ele = ele . _replace ( left = ele . left / 2.0 , top = ele . top / 2.0 ) self . state . element = ele yield ele break","title":"find_all()"},{"location":"bot/#botcity.core.bot.DesktopBot.find_multiple","text":"Find multiple elements defined by label on screen until a timeout happens. Parameters: Name Type Description Default labels list A list of image identifiers required x int Search region start position x. Defaults to 0. None y int Search region start position y. Defaults to 0. None width int Search region width. Defaults to screen width. None height int Search region height. Defaults to screen height. None threshold int The threshold to be applied when doing grayscale search. Defaults to None. None matching float The matching index ranging from 0 to 1. Defaults to 0.9. 0.9 waiting_time int Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s). 10000 best bool Whether or not to keep looking until the best matching is found. Defaults to True. True grayscale bool Whether or not to convert to grayscale before searching. Defaults to False. False Returns: Type Description results (dict) A dictionary in which the key is the label and value are the element coordinates in a NamedTuple. Source code in core/bot.py def find_multiple ( self , labels , x = None , y = None , width = None , height = None , * , threshold = None , matching = 0.9 , waiting_time = 10000 , best = True , grayscale = False ): \"\"\" Find multiple elements defined by label on screen until a timeout happens. Args: labels (list): A list of image identifiers x (int, optional): Search region start position x. Defaults to 0. y (int, optional): Search region start position y. Defaults to 0. width (int, optional): Search region width. Defaults to screen width. height (int, optional): Search region height. Defaults to screen height. threshold (int, optional): The threshold to be applied when doing grayscale search. Defaults to None. matching (float, optional): The matching index ranging from 0 to 1. Defaults to 0.9. waiting_time (int, optional): Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s). best (bool, optional): Whether or not to keep looking until the best matching is found. Defaults to True. grayscale (bool, optional): Whether or not to convert to grayscale before searching. Defaults to False. Returns: results (dict): A dictionary in which the key is the label and value are the element coordinates in a NamedTuple. \"\"\" def _to_dict ( lbs , elems ): return { k : v for k , v in zip ( lbs , elems )} screen_w , screen_h = pyautogui . size () x = x or 0 y = y or 0 w = width or screen_w h = height or screen_h region = ( x , y , w , h ) results = [ None ] * len ( labels ) paths = [ self . _search_image_file ( la ) for la in labels ] if threshold : # TODO: Figure out how we should do threshold print ( 'Threshold not yet supported' ) if not best : # TODO: Implement best=False. print ( 'Warning: Ignoring best=False for now. It will be supported in the future.' ) start_time = time . time () n_cpus = multiprocessing . cpu_count () - 1 while True : elapsed_time = ( time . time () - start_time ) * 1000 if elapsed_time > waiting_time : return _to_dict ( labels , results ) haystack = pyautogui . screenshot () helper = functools . partial ( self . _find_multiple_helper , haystack , region , matching , grayscale ) with multiprocessing . Pool ( processes = n_cpus ) as pool : results = pool . map ( helper , paths ) results = [ self . _fix_retina_element ( r ) for r in results ] if None in results : continue else : return _to_dict ( labels , results )","title":"find_multiple()"},{"location":"bot/#botcity.core.bot.DesktopBot.find_text","text":"Find an element defined by label on screen until a timeout happens. Parameters: Name Type Description Default label str The image identifier required x int Search region start position x. Defaults to 0. None y int Search region start position y. Defaults to 0. None width int Search region width. Defaults to screen width. None height int Search region height. Defaults to screen height. None threshold int The threshold to be applied when doing grayscale search. Defaults to None. None matching float The matching index ranging from 0 to 1. Defaults to 0.9. 0.9 waiting_time int Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s). 10000 best bool Whether or not to keep looking until the best matching is found. Defaults to True. True Returns: Type Description element (NamedTuple) The element coordinates. None if not found. Source code in core/bot.py def find_text ( self , label , x = None , y = None , width = None , height = None , * , threshold = None , matching = 0.9 , waiting_time = 10000 , best = True ): \"\"\" Find an element defined by label on screen until a timeout happens. Args: label (str): The image identifier x (int, optional): Search region start position x. Defaults to 0. y (int, optional): Search region start position y. Defaults to 0. width (int, optional): Search region width. Defaults to screen width. height (int, optional): Search region height. Defaults to screen height. threshold (int, optional): The threshold to be applied when doing grayscale search. Defaults to None. matching (float, optional): The matching index ranging from 0 to 1. Defaults to 0.9. waiting_time (int, optional): Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s). best (bool, optional): Whether or not to keep looking until the best matching is found. Defaults to True. Returns: element (NamedTuple): The element coordinates. None if not found. \"\"\" return self . find_until ( label , x , y , width , height , threshold = threshold , matching = matching , waiting_time = waiting_time , best = best , grayscale = True )","title":"find_text()"},{"location":"bot/#botcity.core.bot.DesktopBot.find_until","text":"Find an element defined by label on screen until a timeout happens. Parameters: Name Type Description Default label str The image identifier required x int Search region start position x. Defaults to 0. None y int Search region start position y. Defaults to 0. None width int Search region width. Defaults to screen width. None height int Search region height. Defaults to screen height. None threshold int The threshold to be applied when doing grayscale search. Defaults to None. None matching float The matching index ranging from 0 to 1. Defaults to 0.9. 0.9 waiting_time int Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s). 10000 best bool Whether or not to keep looking until the best matching is found. Defaults to True. True grayscale bool Whether or not to convert to grayscale before searching. Defaults to False. False Returns: Type Description element (NamedTuple) The element coordinates. None if not found. Source code in core/bot.py def find_until ( self , label , x = None , y = None , width = None , height = None , * , threshold = None , matching = 0.9 , waiting_time = 10000 , best = True , grayscale = False ): \"\"\" Find an element defined by label on screen until a timeout happens. Args: label (str): The image identifier x (int, optional): Search region start position x. Defaults to 0. y (int, optional): Search region start position y. Defaults to 0. width (int, optional): Search region width. Defaults to screen width. height (int, optional): Search region height. Defaults to screen height. threshold (int, optional): The threshold to be applied when doing grayscale search. Defaults to None. matching (float, optional): The matching index ranging from 0 to 1. Defaults to 0.9. waiting_time (int, optional): Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s). best (bool, optional): Whether or not to keep looking until the best matching is found. Defaults to True. grayscale (bool, optional): Whether or not to convert to grayscale before searching. Defaults to False. Returns: element (NamedTuple): The element coordinates. None if not found. \"\"\" self . state . element = None screen_w , screen_h = pyautogui . size () x = x or 0 y = y or 0 w = width or screen_w h = height or screen_h region = ( x , y , w , h ) element_path = self . _search_image_file ( label ) if threshold : # TODO: Figure out how we should do threshold print ( 'Threshold not yet supported' ) if not best : # TODO: Implement best=False. print ( 'Warning: Ignoring best=False for now. It will be supported in the future.' ) start_time = time . time () while True : elapsed_time = ( time . time () - start_time ) * 1000 if elapsed_time > waiting_time : return None ele = pyautogui . locateOnScreen ( element_path , region = region , confidence = matching , grayscale = grayscale ) if ele is not None : if is_retina (): ele = ele . _replace ( left = ele . left / 2.0 , top = ele . top / 2.0 ) self . state . element = ele return ele","title":"find_until()"},{"location":"bot/#botcity.core.bot.DesktopBot.get_clipboard","text":"Get the current content in the clipboard. Returns: Type Description text (str) Current clipboard content Source code in core/bot.py def get_clipboard ( self ): \"\"\" Get the current content in the clipboard. Returns: text (str): Current clipboard content \"\"\" return pyperclip . paste ()","title":"get_clipboard()"},{"location":"bot/#botcity.core.bot.DesktopBot.get_element_coords","text":"Find an element defined by label on screen and returns its coordinates. Parameters: Name Type Description Default label str The image identifier required x int X (Left) coordinate of the search area. None y int Y (Top) coordinate of the search area. None width int Width of the search area. None height int Height of the search area. None matching float Minimum score to consider a match in the element image recognition process. Defaults to 0.9. 0.9 best bool Whether or not to search for the best value. If False the method returns on the first find. Defaults to True. True Returns: Type Description coords (Tuple) A tuple containing the x and y coordinates for the element. Source code in core/bot.py def get_element_coords ( self , label , x = None , y = None , width = None , height = None , matching = 0.9 , best = True ): \"\"\" Find an element defined by label on screen and returns its coordinates. Args: label (str): The image identifier x (int, optional): X (Left) coordinate of the search area. y (int, optional): Y (Top) coordinate of the search area. width (int, optional): Width of the search area. height (int, optional): Height of the search area. matching (float, optional): Minimum score to consider a match in the element image recognition process. Defaults to 0.9. best (bool, optional): Whether or not to search for the best value. If False the method returns on the first find. Defaults to True. Returns: coords (Tuple): A tuple containing the x and y coordinates for the element. \"\"\" self . state . element = None screen_size = pyautogui . size () x = x or 0 y = y or 0 width = width or screen_size . width height = height or screen_size . height region = ( x , y , width , height ) if not best : print ( 'Warning: Ignoring best=False for now. It will be supported in the future.' ) ele = pyautogui . locateOnScreen ( self . _search_image_file ( label ), region = region , confidence = matching ) if is_retina (): ele = ele . _replace ( left = ele . left / 2.0 , top = ele . top / 2.0 ) self . state . element = ele return ele . left , ele . top","title":"get_element_coords()"},{"location":"bot/#botcity.core.bot.DesktopBot.get_element_coords_centered","text":"Find an element defined by label on screen and returns its centered coordinates. Parameters: Name Type Description Default label str The image identifier required x int X (Left) coordinate of the search area. None y int Y (Top) coordinate of the search area. None width int Width of the search area. None height int Height of the search area. None matching float Minimum score to consider a match in the element image recognition process. Defaults to 0.9. 0.9 best bool Whether or not to search for the best value. If False the method returns on the first find. Defaults to True. True Returns: Type Description coords (Tuple) A tuple containing the x and y coordinates for the center of the element. Source code in core/bot.py def get_element_coords_centered ( self , label , x = None , y = None , width = None , height = None , matching = 0.9 , best = True ): \"\"\" Find an element defined by label on screen and returns its centered coordinates. Args: label (str): The image identifier x (int, optional): X (Left) coordinate of the search area. y (int, optional): Y (Top) coordinate of the search area. width (int, optional): Width of the search area. height (int, optional): Height of the search area. matching (float, optional): Minimum score to consider a match in the element image recognition process. Defaults to 0.9. best (bool, optional): Whether or not to search for the best value. If False the method returns on the first find. Defaults to True. Returns: coords (Tuple): A tuple containing the x and y coordinates for the center of the element. \"\"\" self . get_element_coords ( label , x , y , width , height , matching , best ) return self . state . center ()","title":"get_element_coords_centered()"},{"location":"bot/#botcity.core.bot.DesktopBot.get_image_from_map","text":"Return an image from teh state image map. Parameters: Name Type Description Default label str The image identifier required Returns: Type Description Image The Image object Source code in core/bot.py def get_image_from_map ( self , label ): \"\"\" Return an image from teh state image map. Args: label (str): The image identifier Returns: Image: The Image object \"\"\" path = self . state . map_images . get ( label ) if not path : raise KeyError ( 'Invalid label for image map.' ) img = Image . open ( path ) return img","title":"get_image_from_map()"},{"location":"bot/#botcity.core.bot.DesktopBot.get_last_element","text":"Return the last element found. Returns: Type Description element (NamedTuple) The element coordinates (left, top, width, height) Source code in core/bot.py def get_last_element ( self ): \"\"\" Return the last element found. Returns: element (NamedTuple): The element coordinates (left, top, width, height) \"\"\" return self . state . element","title":"get_last_element()"},{"location":"bot/#botcity.core.bot.DesktopBot.get_last_x","text":"Get the last X position for the mouse. Returns: Type Description x (int) The last x position for the mouse. Source code in core/bot.py def get_last_x ( self ): \"\"\" Get the last X position for the mouse. Returns: x (int): The last x position for the mouse. \"\"\" return pyautogui . position () . x","title":"get_last_x()"},{"location":"bot/#botcity.core.bot.DesktopBot.get_last_y","text":"Get the last Y position for the mouse. Returns: Type Description y (int) The last y position for the mouse. Source code in core/bot.py def get_last_y ( self ): \"\"\" Get the last Y position for the mouse. Returns: y (int): The last y position for the mouse. \"\"\" return pyautogui . position () . y","title":"get_last_y()"},{"location":"bot/#botcity.core.bot.DesktopBot.get_screenshot","text":"Capture a screenshot. Parameters: Name Type Description Default filepath str The filepath in which to save the screenshot. Defaults to None. None region tuple Bounding box containing left, top, width and height to crop screenshot. None Returns: Type Description Image The screenshot Image object Source code in core/bot.py def get_screenshot ( self , filepath = None , region = None ): \"\"\" Capture a screenshot. Args: filepath (str, optional): The filepath in which to save the screenshot. Defaults to None. region (tuple, optional): Bounding box containing left, top, width and height to crop screenshot. Returns: Image: The screenshot Image object \"\"\" return self . screenshot ( filepath , region )","title":"get_screenshot()"},{"location":"bot/#botcity.core.bot.DesktopBot.hold_shift","text":"Hold key Shift Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def hold_shift ( self , wait = 0 ): \"\"\" Hold key Shift Args: wait (int, optional): Wait interval (ms) after task \"\"\" pyautogui . keyDown ( 'shift' ) self . sleep ( wait )","title":"hold_shift()"},{"location":"bot/#botcity.core.bot.DesktopBot.kb_type","text":"Type a text char by char (individual key events). Parameters: Name Type Description Default text str text to be typed. required interval int interval (ms) between each key press. Defaults to 0 0 Source code in core/bot.py def kb_type ( self , text , interval = 0 ): \"\"\" Type a text char by char (individual key events). Args: text (str): text to be typed. interval (int, optional): interval (ms) between each key press. Defaults to 0 \"\"\" pyautogui . write ( text , interval = interval / 1000.0 ) self . sleep ( config . DEFAULT_SLEEP_AFTER_ACTION )","title":"kb_type()"},{"location":"bot/#botcity.core.bot.DesktopBot.key_end","text":"Press key End Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def key_end ( self , wait = 0 ): \"\"\" Press key End Args: wait (int, optional): Wait interval (ms) after task \"\"\" pyautogui . press ( 'end' ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay )","title":"key_end()"},{"location":"bot/#botcity.core.bot.DesktopBot.key_enter","text":"Press key Enter Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def key_enter ( self , wait = 0 ): \"\"\" Press key Enter Args: wait (int, optional): Wait interval (ms) after task \"\"\" self . enter ( wait )","title":"key_enter()"},{"location":"bot/#botcity.core.bot.DesktopBot.key_esc","text":"Press key Esc Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def key_esc ( self , wait = 0 ): \"\"\" Press key Esc Args: wait (int, optional): Wait interval (ms) after task \"\"\" pyautogui . press ( 'esc' ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay )","title":"key_esc()"},{"location":"bot/#botcity.core.bot.DesktopBot.key_right","text":"Press key Right Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def key_right ( self , wait = 0 ): \"\"\" Press key Right Args: wait (int, optional): Wait interval (ms) after task \"\"\" pyautogui . press ( 'right' ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay )","title":"key_right()"},{"location":"bot/#botcity.core.bot.DesktopBot.maximize_window","text":"Shortcut to maximize window on Windows OS. Source code in core/bot.py def maximize_window ( self ): \"\"\" Shortcut to maximize window on Windows OS. \"\"\" self . alt_space () self . sleep ( 1000 ) pyautogui . press ( 'x' )","title":"maximize_window()"},{"location":"bot/#botcity.core.bot.DesktopBot.mouse_down","text":"Holds down the requested mouse button. Parameters: Name Type Description Default wait_after int Interval to wait after clicking on the element. 300 button str One of 'left', 'right', 'middle'. Defaults to 'left' 'left' Source code in core/bot.py def mouse_down ( self , wait_after = config . DEFAULT_SLEEP_AFTER_ACTION , * , button = 'left' ): \"\"\" Holds down the requested mouse button. Args: wait_after (int, optional): Interval to wait after clicking on the element. button (str, optional): One of 'left', 'right', 'middle'. Defaults to 'left' \"\"\" pyautogui . mouseDown ( button = button ) self . sleep ( wait_after )","title":"mouse_down()"},{"location":"bot/#botcity.core.bot.DesktopBot.mouse_move","text":"Mouse the move to the coordinate defined by x and y Parameters: Name Type Description Default x int The X coordinate required y int The Y coordinate required Source code in core/bot.py def mouse_move ( self , x , y ): \"\"\" Mouse the move to the coordinate defined by x and y Args: x (int): The X coordinate y (int): The Y coordinate \"\"\" pyautogui . moveTo ( x , y )","title":"mouse_move()"},{"location":"bot/#botcity.core.bot.DesktopBot.mouse_up","text":"Releases the requested mouse button. Parameters: Name Type Description Default wait_after int Interval to wait after clicking on the element. 300 button str One of 'left', 'right', 'middle'. Defaults to 'left' 'left' Source code in core/bot.py def mouse_up ( self , wait_after = config . DEFAULT_SLEEP_AFTER_ACTION , * , button = 'left' ): \"\"\" Releases the requested mouse button. Args: wait_after (int, optional): Interval to wait after clicking on the element. button (str, optional): One of 'left', 'right', 'middle'. Defaults to 'left' \"\"\" pyautogui . mouseUp ( button = button ) self . sleep ( wait_after )","title":"mouse_up()"},{"location":"bot/#botcity.core.bot.DesktopBot.move","text":"Move to the center position of last found item. Source code in core/bot.py @only_if_element def move ( self ): \"\"\" Move to the center position of last found item. \"\"\" x , y = self . state . center () pyautogui . moveTo ( x , y )","title":"move()"},{"location":"bot/#botcity.core.bot.DesktopBot.move_random","text":"Move randomly along the given x, y range. Parameters: Name Type Description Default range_x int Horizontal range required range_y int Vertical range required Source code in core/bot.py def move_random ( self , range_x , range_y ): \"\"\" Move randomly along the given x, y range. Args: range_x (int): Horizontal range range_y (int): Vertical range \"\"\" x = int ( random . random () * range_x ) y = int ( random . random () * range_y ) pyautogui . moveTo ( x , y )","title":"move_random()"},{"location":"bot/#botcity.core.bot.DesktopBot.move_relative","text":"Move the mouse relative to its current position. Parameters: Name Type Description Default x int Horizontal offset required y int Vertical offset required Source code in core/bot.py def move_relative ( self , x , y ): \"\"\" Move the mouse relative to its current position. Args: x (int): Horizontal offset y (int): Vertical offset \"\"\" x = self . get_last_x () + x y = self . get_last_y () + y pyautogui . moveTo ( x , y )","title":"move_relative()"},{"location":"bot/#botcity.core.bot.DesktopBot.page_down","text":"Press Page Down key Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def page_down ( self , wait = 0 ): \"\"\" Press Page Down key Args: wait (int, optional): Wait interval (ms) after task \"\"\" pyautogui . press ( 'pagedown' ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay )","title":"page_down()"},{"location":"bot/#botcity.core.bot.DesktopBot.page_up","text":"Press Page Up key Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def page_up ( self , wait = 0 ): \"\"\" Press Page Up key Args: wait (int, optional): Wait interval (ms) after task \"\"\" pyautogui . press ( 'pageup' ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay )","title":"page_up()"},{"location":"bot/#botcity.core.bot.DesktopBot.paste","text":"Paste content from the clipboard. Parameters: Name Type Description Default text str The text to be pasted. Defaults to None None wait int Wait interval (ms) after task 0 Source code in core/bot.py def paste ( self , text = None , wait = 0 ): \"\"\" Paste content from the clipboard. Args: text (str, optional): The text to be pasted. Defaults to None wait (int, optional): Wait interval (ms) after task \"\"\" if text : pyperclip . copy ( text ) self . sleep ( 500 ) self . control_v () delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay )","title":"paste()"},{"location":"bot/#botcity.core.bot.DesktopBot.release_shift","text":"Release key Shift. This method needs to be invoked after holding Shift or similar. Source code in core/bot.py def release_shift ( self ): \"\"\" Release key Shift. This method needs to be invoked after holding Shift or similar. \"\"\" pyautogui . keyUp ( 'shift' )","title":"release_shift()"},{"location":"bot/#botcity.core.bot.DesktopBot.right_click","text":"Right click on the last found element. Parameters: Name Type Description Default wait_after int Interval to wait after clicking on the element. 300 clicks int Number of times to click. Defaults to 1. 1 interval_between_clicks int The interval between clicks in ms. Defaults to 0. 0 Source code in core/bot.py @only_if_element def right_click ( self , wait_after = config . DEFAULT_SLEEP_AFTER_ACTION , * , clicks = 1 , interval_between_clicks = 0 ): \"\"\" Right click on the last found element. Args: wait_after (int, optional): Interval to wait after clicking on the element. clicks (int, optional): Number of times to click. Defaults to 1. interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0. \"\"\" x , y = self . state . center () os_compat . click ( x , y , clicks = clicks , button = 'right' , interval = interval_between_clicks / 1000.0 ) self . sleep ( wait_after )","title":"right_click()"},{"location":"bot/#botcity.core.bot.DesktopBot.right_click_at","text":"Right click at the coordinate defined by x and y Parameters: Name Type Description Default x int The X coordinate required y int The Y coordinate required Source code in core/bot.py def right_click_at ( self , x , y ): \"\"\" Right click at the coordinate defined by x and y Args: x (int): The X coordinate y (int): The Y coordinate \"\"\" os_compat . click ( x , y , button = 'right' )","title":"right_click_at()"},{"location":"bot/#botcity.core.bot.DesktopBot.right_click_relative","text":"Right Click Relative on the last found element. Parameters: Name Type Description Default x int Horizontal offset required y int Vertical offset required interval_between_clicks int The interval between clicks in ms. Defaults to 0. 0 wait_after int Interval to wait after clicking on the element. 300 Source code in core/bot.py @only_if_element def right_click_relative ( self , x , y , interval_between_clicks = 0 , wait_after = config . DEFAULT_SLEEP_AFTER_ACTION ): \"\"\" Right Click Relative on the last found element. Args: x (int): Horizontal offset y (int): Vertical offset interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0. wait_after (int, optional): Interval to wait after clicking on the element. \"\"\" x = self . state . x () + x y = self . state . y () + y self . click_relative ( x , y , wait_after = wait_after , clicks = 3 , interval_between_clicks = interval_between_clicks , button = 'right' )","title":"right_click_relative()"},{"location":"bot/#botcity.core.bot.DesktopBot.save_screenshot","text":"Saves a screenshot in a given path. Parameters: Name Type Description Default path str The filepath in which to save the screenshot required Source code in core/bot.py def save_screenshot ( self , path ): \"\"\" Saves a screenshot in a given path. Args: path (str): The filepath in which to save the screenshot \"\"\" pyautogui . screenshot ( path )","title":"save_screenshot()"},{"location":"bot/#botcity.core.bot.DesktopBot.screen_cut","text":"Capture a screenshot from a region of the screen. Parameters: Name Type Description Default x int region start position x required y int region start position y required width int region width None height int region height None Returns: Type Description Image The screenshot Image object Source code in core/bot.py def screen_cut ( self , x , y , width = None , height = None ): \"\"\" Capture a screenshot from a region of the screen. Args: x (int): region start position x y (int): region start position y width (int): region width height (int): region height Returns: Image: The screenshot Image object \"\"\" screen_size = pyautogui . size () x = x or 0 y = y or 0 width = width or screen_size . width height = height or screen_size . height img = pyautogui . screenshot ( region = ( x , y , width , height )) return img","title":"screen_cut()"},{"location":"bot/#botcity.core.bot.DesktopBot.screenshot","text":"Capture a screenshot. Parameters: Name Type Description Default filepath str The filepath in which to save the screenshot. Defaults to None. None region tuple Bounding box containing left, top, width and height to crop screenshot. None Returns: Type Description Image The screenshot Image object Source code in core/bot.py def screenshot ( self , filepath = None , region = None ): \"\"\" Capture a screenshot. Args: filepath (str, optional): The filepath in which to save the screenshot. Defaults to None. region (tuple, optional): Bounding box containing left, top, width and height to crop screenshot. Returns: Image: The screenshot Image object \"\"\" img = pyautogui . screenshot ( filepath , region ) return img","title":"screenshot()"},{"location":"bot/#botcity.core.bot.DesktopBot.scroll_down","text":"Scroll Down n clicks Parameters: Name Type Description Default clicks int Number of times to scroll down. required Source code in core/bot.py def scroll_down ( self , clicks ): \"\"\" Scroll Down n clicks Args: clicks (int): Number of times to scroll down. \"\"\" pyautogui . scroll ( - 1 * clicks )","title":"scroll_down()"},{"location":"bot/#botcity.core.bot.DesktopBot.scroll_up","text":"Scroll Up n clicks Parameters: Name Type Description Default clicks int Number of times to scroll up. required Source code in core/bot.py def scroll_up ( self , clicks ): \"\"\" Scroll Up n clicks Args: clicks (int): Number of times to scroll up. \"\"\" pyautogui . scroll ( clicks )","title":"scroll_up()"},{"location":"bot/#botcity.core.bot.DesktopBot.shift_tab","text":"Press keys Shift+Tab Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def shift_tab ( self , wait = 0 ): \"\"\" Press keys Shift+Tab Args: wait (int, optional): Wait interval (ms) after task \"\"\" pyautogui . hotkey ( 'shift' , 'tab' , interval = 0.25 ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay )","title":"shift_tab()"},{"location":"bot/#botcity.core.bot.DesktopBot.sleep","text":"Wait / Sleep for a given interval. Parameters: Name Type Description Default interval int Interval in milliseconds required Source code in core/bot.py def sleep ( self , interval ): \"\"\" Wait / Sleep for a given interval. Args: interval (int): Interval in milliseconds \"\"\" self . wait ( interval )","title":"sleep()"},{"location":"bot/#botcity.core.bot.DesktopBot.space","text":"Press Space key Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def space ( self , wait = 0 ): \"\"\" Press Space key Args: wait (int, optional): Wait interval (ms) after task \"\"\" pyautogui . press ( 'space' ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay )","title":"space()"},{"location":"bot/#botcity.core.bot.DesktopBot.tab","text":"Press key Tab Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def tab ( self , wait = 0 ): \"\"\" Press key Tab Args: wait (int, optional): Wait interval (ms) after task \"\"\" pyautogui . press ( 'tab' ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay )","title":"tab()"},{"location":"bot/#botcity.core.bot.DesktopBot.triple_click","text":"Triple Click on the last found element. Parameters: Name Type Description Default wait_after int Interval to wait after clicking on the element. 300 Source code in core/bot.py @only_if_element def triple_click ( self , wait_after = config . DEFAULT_SLEEP_AFTER_ACTION ): \"\"\" Triple Click on the last found element. Args: wait_after (int, optional): Interval to wait after clicking on the element. \"\"\" self . click ( wait_after = wait_after , clicks = 3 )","title":"triple_click()"},{"location":"bot/#botcity.core.bot.DesktopBot.triple_click_relative","text":"Triple Click Relative on the last found element. Parameters: Name Type Description Default x int Horizontal offset required y int Vertical offset required interval_between_clicks int The interval between clicks in ms. Defaults to 0. 0 wait_after int Interval to wait after clicking on the element. 300 Source code in core/bot.py @only_if_element def triple_click_relative ( self , x , y , interval_between_clicks = 0 , wait_after = config . DEFAULT_SLEEP_AFTER_ACTION ): \"\"\" Triple Click Relative on the last found element. Args: x (int): Horizontal offset y (int): Vertical offset interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0. wait_after (int, optional): Interval to wait after clicking on the element. \"\"\" self . click_relative ( x , y , wait_after = wait_after , clicks = 3 , interval_between_clicks = interval_between_clicks )","title":"triple_click_relative()"},{"location":"bot/#botcity.core.bot.DesktopBot.type_down","text":"Press Down key Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def type_down ( self , wait = 0 ): \"\"\" Press Down key Args: wait (int, optional): Wait interval (ms) after task \"\"\" pyautogui . press ( 'down' ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay )","title":"type_down()"},{"location":"bot/#botcity.core.bot.DesktopBot.type_key","text":"Type a text char by char (individual key events). Parameters: Name Type Description Default text str text to be typed. required interval int interval (ms) between each key press. Defaults to 0 0 Source code in core/bot.py def type_key ( self , text , interval = 0 ): \"\"\" Type a text char by char (individual key events). Args: text (str): text to be typed. interval (int, optional): interval (ms) between each key press. Defaults to 0 \"\"\" self . kb_type ( text = text , interval = interval / 1000.0 )","title":"type_key()"},{"location":"bot/#botcity.core.bot.DesktopBot.type_keys","text":"Press a sequence of keys. Hold the keys in the specific order and releases them. Parameters: Name Type Description Default keys list List of keys to be pressed required Source code in core/bot.py def type_keys ( self , keys ): \"\"\" Press a sequence of keys. Hold the keys in the specific order and releases them. Args: keys (list): List of keys to be pressed \"\"\" self . type_keys_with_interval ( 100 , keys )","title":"type_keys()"},{"location":"bot/#botcity.core.bot.DesktopBot.type_keys_with_interval","text":"Press a sequence of keys. Hold the keys in the specific order and releases them. Parameters: Name Type Description Default interval int Interval (ms) in which to press and release keys required keys list List of keys to be pressed required Source code in core/bot.py def type_keys_with_interval ( self , interval , keys ): \"\"\" Press a sequence of keys. Hold the keys in the specific order and releases them. Args: interval (int): Interval (ms) in which to press and release keys keys (list): List of keys to be pressed \"\"\" pyautogui . hotkey ( * keys , interval = interval / 1000.0 )","title":"type_keys_with_interval()"},{"location":"bot/#botcity.core.bot.DesktopBot.type_left","text":"Press Left key Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def type_left ( self , wait = 0 ): \"\"\" Press Left key Args: wait (int, optional): Wait interval (ms) after task \"\"\" pyautogui . press ( 'left' ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay )","title":"type_left()"},{"location":"bot/#botcity.core.bot.DesktopBot.type_right","text":"Press Right key Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def type_right ( self , wait = 0 ): \"\"\" Press Right key Args: wait (int, optional): Wait interval (ms) after task \"\"\" pyautogui . press ( 'right' ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay )","title":"type_right()"},{"location":"bot/#botcity.core.bot.DesktopBot.type_up","text":"Press Up key Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def type_up ( self , wait = 0 ): \"\"\" Press Up key Args: wait (int, optional): Wait interval (ms) after task \"\"\" pyautogui . press ( 'up' ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay )","title":"type_up()"},{"location":"bot/#botcity.core.bot.DesktopBot.type_windows","text":"Press Win logo key Parameters: Name Type Description Default wait int Wait interval (ms) after task 0 Source code in core/bot.py def type_windows ( self , wait = 0 ): \"\"\" Press Win logo key Args: wait (int, optional): Wait interval (ms) after task \"\"\" pyautogui . press ( 'win' ) delay = max ( 0 , wait or config . DEFAULT_SLEEP_AFTER_ACTION ) self . sleep ( delay )","title":"type_windows()"},{"location":"bot/#botcity.core.bot.DesktopBot.wait","text":"Wait / Sleep for a given interval. Parameters: Name Type Description Default interval int Interval in milliseconds required Source code in core/bot.py def wait ( self , interval ): \"\"\" Wait / Sleep for a given interval. Args: interval (int): Interval in milliseconds \"\"\" time . sleep ( interval / 1000.0 )","title":"wait()"},{"location":"bot/#botcity.core.bot.DesktopBot.wait_for_file","text":"Invoke the system handler to open the given file. Parameters: Name Type Description Default path str The path for the file to be executed required timeout int Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s). 10000 Returns status (bool): Whether or not the file was available before the timeout Source code in core/bot.py def wait_for_file ( self , path , timeout = 10000 ): \"\"\" Invoke the system handler to open the given file. Args: path (str): The path for the file to be executed timeout (int, optional): Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s). Returns status (bool): Whether or not the file was available before the timeout \"\"\" start_time = time . time () while True : elapsed_time = ( time . time () - start_time ) * 1000 if elapsed_time > timeout : return False if os . path . isfile ( path ) and os . access ( path , os . R_OK ): return True self . sleep ( config . DEFAULT_SLEEP_AFTER_ACTION )","title":"wait_for_file()"},{"location":"intro/","text":"Getting Started After you installed this package, the next step is to import the package into your code and start using the functions to build your RPA pipeline. from botcity.core import DesktopBot As a demonstration of the library, let's build a simple bot together that will open BotCity's website in your browser. Opening the browser To open the browser you can leverage the browser method which takes as argument a URL. bot = DesktopBot () bot . browser ( \"https://www.botcity.dev/en\" ) You can use this framework in two ways: Scripting using the functions Creating a Bot class The second method is the best if you plan to integrate your bot with the BotCity Maestro SDK. The template project uses the Bot class and the examples cover both approaches. Template Project We created a template project using Cookiecutter to help you create new bots using BotCity's Python Framework. Take a look into the template project website for more information on how to use it and get started. Next Steps Check our examples and experiment with the API. Let us know where it can be improved. Have fun automating!","title":"Getting Started"},{"location":"intro/#getting-started","text":"After you installed this package, the next step is to import the package into your code and start using the functions to build your RPA pipeline. from botcity.core import DesktopBot As a demonstration of the library, let's build a simple bot together that will open BotCity's website in your browser.","title":"Getting Started"},{"location":"intro/#opening-the-browser","text":"To open the browser you can leverage the browser method which takes as argument a URL. bot = DesktopBot () bot . browser ( \"https://www.botcity.dev/en\" ) You can use this framework in two ways: Scripting using the functions Creating a Bot class The second method is the best if you plan to integrate your bot with the BotCity Maestro SDK. The template project uses the Bot class and the examples cover both approaches.","title":"Opening the browser"},{"location":"intro/#template-project","text":"We created a template project using Cookiecutter to help you create new bots using BotCity's Python Framework. Take a look into the template project website for more information on how to use it and get started.","title":"Template Project"},{"location":"intro/#next-steps","text":"Check our examples and experiment with the API. Let us know where it can be improved. Have fun automating!","title":"Next Steps"}]}