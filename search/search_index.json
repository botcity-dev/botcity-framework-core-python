{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"<p>Welcome to BotCity's Framework Core Python package for RPA. </p>"},{"location":"#installation","title":"Installation","text":""},{"location":"#latest-release","title":"Latest release","text":""},{"location":"#using-pypi","title":"Using PyPI","text":"<pre><code>pip install botcity-framework-core\n</code></pre>"},{"location":"#using-conda-forge-coming-soon","title":"Using conda-forge - Coming Soon","text":"<pre><code>conda install -c conda-forge botcity-framework-core\n</code></pre>"},{"location":"#latest-code","title":"Latest code","text":"<pre><code>pip install git+https://github.com/botcity-dev/botcity-framework-core-python.git\n</code></pre>"},{"location":"#important-linux","title":"Important - Linux","text":"<p>For Linux it may be necessary to install the Python 3 Tk library as well as scrot (Screenshot tool).</p> <pre><code>apt install python3-tk\n\napt install scrot\n\napt install xclip\n</code></pre>"},{"location":"bot/","title":"Framework","text":"<p>The <code>botcity.core</code> module contains specialized implementations aimed at Desktop automation such as <code>DesktopBot</code> which is described below.</p> <p>You are expected to implement the <code>action</code> method of the <code>DesktopBot</code> class in your Bot class.</p> <p>Here is a very brief example of a bot which opens the BotCity website:</p> <pre><code>from botcity.core import DesktopBot\n\n\nclass Bot(DesktopBot):\n    def action(self, execution=None):\n        # Opens the BotCity website.\n        self.browse(\"https://botcity.dev\")\n\n\nif __name__ == '__main__':\n    Bot.main()\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot","title":"<code>botcity.core.bot.DesktopBot</code>","text":"<p>         Bases: <code>BaseBot</code></p> <p>Base class for Desktop Bots. Users must implement the <code>action</code> method in their classes.</p> <p>Attributes:</p> Name Type Description <code>state</code> <code>State</code> <p>The internal state of this bot.</p> <code>maestro</code> <code>BotMaestroSDK</code> <p>an instance to interact with the BotMaestro server.</p> Source code in <code>botcity/core/bot.py</code> <pre><code>class DesktopBot(BaseBot):\n\"\"\"\n    Base class for Desktop Bots.\n    Users must implement the `action` method in their classes.\n\n    Attributes:\n        state (State): The internal state of this bot.\n        maestro (BotMaestroSDK): an instance to interact with the BotMaestro server.\n\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self._app = None\n        self.state = State()\n        self.maestro = BotMaestroSDK() if MAESTRO_AVAILABLE else None\n        self._interval = 0.005 if platform.system() == \"Darwin\" else 0.0\n        # For parity with Java\n        self.addImage = self.add_image\n        self.getImageFromMap = self.get_image_from_map\n        self.getLastElement = self.get_last_element\n        self.getScreenShot = self.get_screenshot\n        self.screenCut = self.screen_cut\n        self.saveScreenshot = self.save_screenshot\n        self.getCoordinates = self.get_element_coords\n        self.getElementCoords = self.get_element_coords\n        self.getElementCoordsCentered = self.get_element_coords_centered\n        self.find = self.find_until\n        self.findUntil = self.find_until\n        self.findText = self.find_text\n        self.findLastUntil = self.find_until\n\n        # Java API compatibility\n        self.clickOn = self.click_on\n        self.getLastX = self.get_last_x\n        self.getLastY = self.get_last_y\n        self.mouseMove = self.mouse_move\n        self.clickAt = self.click_at\n        self.doubleclick = self.double_click\n        self.doubleClick = self.double_click\n        self.doubleClickRelative = self.double_click_relative\n        self.tripleClick = self.triple_click\n        self.tripleClickRelative = self.triple_click_relative\n        self.scrollDown = self.scroll_down\n        self.scrollUp = self.scroll_up\n        self.moveTo = self.mouse_move\n        self.moveRelative = self.move_relative\n        self.moveRandom = self.move_random\n        self.moveAndClick = self.click\n        self.rightClick = self.right_click\n        self.rightClickAt = self.right_click_at\n        self.rightClickRelative = self.right_click_relative\n        self.moveAndRightClick = self.right_click\n        pyperclip.determine_clipboard()\n\n        # Pynput mouse and kb controller\n        self._kb_controller = KbController()\n        self._mouse_controller = MouseController()\n\n    @property\n    def app(self):\n\"\"\"\n        The connected application instance to be used.\n\n        Returns:\n            app (Application): The connected Application instance.\n        \"\"\"\n        return self._app\n\n    @app.setter\n    def app(self, app):\n\"\"\"\n        The connected application instance to be used.\n\n        Args:\n            app (Application): The connected application to be used.\n        \"\"\"\n        self._app = app\n\n    ##########\n    # Display\n    ##########\n\n    def add_image(self, label, path):\n\"\"\"\n        Add an image into the state image map.\n\n        Args:\n            label (str): The image identifier\n            path (str): The path for the image on disk\n        \"\"\"\n        self.state.map_images[label] = path\n\n    def get_image_from_map(self, label):\n\"\"\"\n        Return an image from teh state image map.\n\n        Args:\n            label (str): The image identifier\n\n        Returns:\n            Image: The Image object\n        \"\"\"\n        path = self.state.map_images.get(label)\n        if not path:\n            raise KeyError('Invalid label for image map.')\n        img = Image.open(path)\n        return img\n\n    def find_multiple(self, labels, x=None, y=None, width=None, height=None, *,\n                      threshold=None, matching=0.9, waiting_time=10000, best=True, grayscale=False):\n\"\"\"\n        Find multiple elements defined by label on screen until a timeout happens.\n\n        Args:\n            labels (list): A list of image identifiers\n            x (int, optional): Search region start position x. Defaults to 0.\n            y (int, optional): Search region start position y. Defaults to 0.\n            width (int, optional): Search region width. Defaults to screen width.\n            height (int, optional): Search region height. Defaults to screen height.\n            threshold (int, optional): The threshold to be applied when doing grayscale search.\n                Defaults to None.\n            matching (float, optional): The matching index ranging from 0 to 1.\n                Defaults to 0.9.\n            waiting_time (int, optional): Maximum wait time (ms) to search for a hit.\n                Defaults to 10000ms (10s).\n            best (bool, optional): Whether or not to keep looking until the best matching is found.\n                Defaults to True.\n            grayscale (bool, optional): Whether or not to convert to grayscale before searching.\n                Defaults to False.\n\n        Returns:\n            results (dict): A dictionary in which the key is the label and value are the element coordinates in a\n               NamedTuple.\n        \"\"\"\n\n        def _to_dict(lbs, elems):\n            return {k: v for k, v in zip(lbs, elems)}\n\n        screen_w, screen_h = self._fix_display_size()\n        x = x or 0\n        y = y or 0\n        w = width or screen_w\n        h = height or screen_h\n\n        region = (x, y, w, h)\n\n        results = [None] * len(labels)\n        paths = [self._search_image_file(la) for la in labels]\n        paths = [self._image_path_as_image(la) for la in paths]\n\n        if threshold:\n            # TODO: Figure out how we should do threshold\n            print('Threshold not yet supported')\n\n        if not best:\n            # TODO: Implement best=False.\n            print('Warning: Ignoring best=False for now. It will be supported in the future.')\n\n        start_time = time.time()\n        n_cpus = multiprocessing.cpu_count() - 1\n\n        while True:\n            elapsed_time = (time.time() - start_time) * 1000\n            if elapsed_time &gt; waiting_time:\n                return _to_dict(labels, results)\n\n            haystack = self.screenshot()\n            helper = functools.partial(self._find_multiple_helper, haystack, region, matching, grayscale)\n\n            with multiprocessing.Pool(processes=n_cpus) as pool:\n                results = pool.map(helper, paths)\n\n            results = [self._fix_retina_element(r) for r in results]\n            if None in results:\n                continue\n            else:\n                return _to_dict(labels, results)\n\n    def _fix_retina_element(self, ele):\n        if not is_retina():\n            return ele\n\n        if ele is not None:\n            if is_retina():\n                ele = ele._replace(left=ele.left / 2.0, top=ele.top / 2.0,\n                                   width=ele.width / 2.0, height=ele.height / 2.0)\n            return ele\n\n    def _fix_display_size(self):\n        width, height = ImageGrab.grab().size\n\n        if not is_retina():\n            return width, height\n\n        return int(width*2), int(height*2)\n\n    def _find_multiple_helper(self, haystack, region, confidence, grayscale, needle):\n        ele = cv2find.locate_all_opencv(needle, haystack, region=region,\n                                        confidence=confidence, grayscale=grayscale)\n        return ele\n\n    def find(self, label, x=None, y=None, width=None, height=None, *, threshold=None,\n             matching=0.9, waiting_time=10000, best=True, grayscale=False):\n\"\"\"\n        Find an element defined by label on screen until a timeout happens.\n\n        Args:\n            label (str): The image identifier\n            x (int, optional): Search region start position x. Defaults to 0.\n            y (int, optional): Search region start position y. Defaults to 0.\n            width (int, optional): Search region width. Defaults to screen width.\n            height (int, optional): Search region height. Defaults to screen height.\n            threshold (int, optional): The threshold to be applied when doing grayscale search.\n                Defaults to None.\n            matching (float, optional): The matching index ranging from 0 to 1.\n                Defaults to 0.9.\n            waiting_time (int, optional): Maximum wait time (ms) to search for a hit.\n                Defaults to 10000ms (10s).\n            best (bool, optional): Whether or not to keep looking until the best matching is found.\n                Defaults to True.\n            grayscale (bool, optional): Whether or not to convert to grayscale before searching.\n                Defaults to False.\n\n        Returns:\n            element (NamedTuple): The element coordinates. None if not found.\n        \"\"\"\n        return self.find_until(label, x=x, y=y, width=width, height=height, threshold=threshold,\n                               matching=matching, waiting_time=waiting_time, best=best, grayscale=grayscale)\n\n    def find_until(self, label, x=None, y=None, width=None, height=None, *,\n                   threshold=None, matching=0.9, waiting_time=10000, best=True, grayscale=False):\n\"\"\"\n        Find an element defined by label on screen until a timeout happens.\n\n        Args:\n            label (str): The image identifier\n            x (int, optional): Search region start position x. Defaults to 0.\n            y (int, optional): Search region start position y. Defaults to 0.\n            width (int, optional): Search region width. Defaults to screen width.\n            height (int, optional): Search region height. Defaults to screen height.\n            threshold (int, optional): The threshold to be applied when doing grayscale search.\n                Defaults to None.\n            matching (float, optional): The matching index ranging from 0 to 1.\n                Defaults to 0.9.\n            waiting_time (int, optional): Maximum wait time (ms) to search for a hit.\n                Defaults to 10000ms (10s).\n            best (bool, optional): Whether or not to keep looking until the best matching is found.\n                Defaults to True.\n            grayscale (bool, optional): Whether or not to convert to grayscale before searching.\n                Defaults to False.\n\n        Returns:\n            element (NamedTuple): The element coordinates. None if not found.\n        \"\"\"\n        self.state.element = None\n        screen_w, screen_h = self._fix_display_size()\n        x = x or 0\n        y = y or 0\n        w = width or screen_w\n        h = height or screen_h\n\n        region = (x, y, w, h)\n\n        element_path = self._search_image_file(label)\n        element_path = self._image_path_as_image(element_path)\n\n        if threshold:\n            # TODO: Figure out how we should do threshold\n            print('Threshold not yet supported')\n\n        if not best:\n            # TODO: Implement best=False.\n            print('Warning: Ignoring best=False for now. It will be supported in the future.')\n\n        start_time = time.time()\n\n        while True:\n            elapsed_time = (time.time() - start_time) * 1000\n            if elapsed_time &gt; waiting_time:\n                return None\n\n            haystack = self.get_screenshot()\n            it = cv2find.locate_all_opencv(element_path, haystack_image=haystack,\n                                           region=region, confidence=matching, grayscale=grayscale)\n            try:\n                ele = next(it)\n            except StopIteration:\n                ele = None\n\n            if ele is not None:\n                ele = self._fix_retina_element(ele)\n                self.state.element = ele\n                return ele\n\n    def find_all(self, label, x=None, y=None, width=None, height=None, *,\n                 threshold=None, matching=0.9, waiting_time=10000, grayscale=False):\n\"\"\"\n        Find all elements defined by label on screen until a timeout happens.\n\n        Args:\n            label (str): The image identifier\n            x (int, optional): Search region start position x. Defaults to 0.\n            y (int, optional): Search region start position y. Defaults to 0.\n            width (int, optional): Search region width. Defaults to screen width.\n            height (int, optional): Search region height. Defaults to screen height.\n            threshold (int, optional): The threshold to be applied when doing grayscale search.\n                Defaults to None.\n            matching (float, optional): The matching index ranging from 0 to 1.\n                Defaults to 0.9.\n            waiting_time (int, optional): Maximum wait time (ms) to search for a hit.\n                Defaults to 10000ms (10s).\n            grayscale (bool, optional): Whether or not to convert to grayscale before searching.\n                Defaults to False.\n\n        Returns:\n            elements (collections.Iterable[NamedTuple]): A generator with all element coordinates fount.\n                None if not found.\n        \"\"\"\n        def deduplicate(elems):\n            def find_same(item, items):\n                x_start = item.left\n                x_end = item.left + item.width\n                y_start = item.top\n                y_end = item.top + item.height\n                similars = []\n                for itm in items:\n                    if itm == item:\n                        continue\n                    if (itm.left &gt;= x_start and itm.left &lt; x_end)\\\n                            and (itm.top &gt;= y_start and itm.top &lt; y_end):\n                        similars.append(itm)\n                        continue\n                return similars\n\n            index = 0\n            while True:\n                try:\n                    dups = find_same(elems[index], elems[index:])\n                    for d in dups:\n                        elems.remove(d)\n                    index += 1\n                except IndexError:\n                    break\n            return elems\n\n        self.state.element = None\n        screen_w, screen_h = self._fix_display_size()\n        x = x or 0\n        y = y or 0\n        w = width or screen_w\n        h = height or screen_h\n\n        region = (x, y, w, h)\n\n        element_path = self._search_image_file(label)\n        element_path = self._image_path_as_image(element_path)\n\n        if threshold:\n            # TODO: Figure out how we should do threshold\n            print('Threshold not yet supported')\n\n        start_time = time.time()\n\n        while True:\n            elapsed_time = (time.time() - start_time) * 1000\n            if elapsed_time &gt; waiting_time:\n                return None\n\n            haystack = self.get_screenshot()\n            eles = cv2find.locate_all_opencv(element_path, haystack_image=haystack,\n                                             region=region, confidence=matching, grayscale=grayscale)\n            if not eles:\n                continue\n            eles = deduplicate(list(eles))\n            for ele in eles:\n                if ele is not None:\n                    ele = self._fix_retina_element(ele)\n                    self.state.element = ele\n                    yield ele\n            break\n\n    def find_text(self, label, x=None, y=None, width=None, height=None, *, threshold=None, matching=0.9,\n                  waiting_time=10000, best=True):\n\"\"\"\n        Find an element defined by label on screen until a timeout happens.\n\n        Args:\n            label (str): The image identifier\n            x (int, optional): Search region start position x. Defaults to 0.\n            y (int, optional): Search region start position y. Defaults to 0.\n            width (int, optional): Search region width. Defaults to screen width.\n            height (int, optional): Search region height. Defaults to screen height.\n            threshold (int, optional): The threshold to be applied when doing grayscale search.\n                Defaults to None.\n            matching (float, optional): The matching index ranging from 0 to 1.\n                Defaults to 0.9.\n            waiting_time (int, optional): Maximum wait time (ms) to search for a hit.\n                Defaults to 10000ms (10s).\n            best (bool, optional): Whether or not to keep looking until the best matching is found.\n                Defaults to True.\n\n        Returns:\n            element (NamedTuple): The element coordinates. None if not found.\n        \"\"\"\n        return self.find_until(label, x, y, width, height, threshold=threshold, matching=matching,\n                               waiting_time=waiting_time, best=best, grayscale=True)\n\n    def find_process(self, name: str = None, pid: str = None) -&gt; List[Process]:\n\"\"\"\n        Find a process by name or PID\n\n        Args:\n            name (str): The process name.\n            pid (str) or (int): The PID (Process Identifier).\n\n        Return:\n            process (psutil.Process): A Process instance.\n        \"\"\"\n        for process in psutil.process_iter():\n            try:\n                if (name is not None and name in process.name()) or \\\n                        (pid is not None and process.pid == pid):\n                    return process\n            except (psutil.NoSuchProcess, psutil.AccessDenied):\n                pass\n        return None\n\n    def terminate_process(self, process: Process):\n\"\"\"\n        Terminate the process via the received Process object.\n\n        Args:\n            process (psutil.Process): The process to terminate.\n        \"\"\"\n        process.terminate()\n        process.wait(10)\n        if process.is_running():\n            raise Exception(\"Terminate process failed\")\n\n    def get_last_element(self):\n\"\"\"\n        Return the last element found.\n\n        Returns:\n            element (NamedTuple): The element coordinates (left, top, width, height)\n        \"\"\"\n        return self.state.element\n\n    def display_size(self):\n\"\"\"\n        Returns the display size in pixels.\n\n        Returns:\n            size (Tuple): The screen dimension (width and height) in pixels.\n        \"\"\"\n        width, height = self._fix_display_size()\n        return width, height\n\n    def screenshot(self, filepath=None, region=None):\n\"\"\"\n        Capture a screenshot.\n\n        Args:\n            filepath (str, optional): The filepath in which to save the screenshot. Defaults to None.\n            region (tuple, optional): Bounding box containing left, top, width and height to crop screenshot.\n\n        Returns:\n            Image: The screenshot Image object\n        \"\"\"\n        img = ImageGrab.grab(bbox=region)\n        if filepath:\n            img.save(filepath)\n        return img\n\n    def get_screenshot(self, filepath=None, region=None):\n\"\"\"\n        Capture a screenshot.\n\n        Args:\n            filepath (str, optional): The filepath in which to save the screenshot. Defaults to None.\n            region (tuple, optional): Bounding box containing left, top, width and height to crop screenshot.\n\n        Returns:\n            Image: The screenshot Image object\n        \"\"\"\n        return self.screenshot(filepath, region)\n\n    def screen_cut(self, x, y, width=None, height=None):\n\"\"\"\n        Capture a screenshot from a region of the screen.\n\n        Args:\n            x (int): region start position x\n            y (int): region start position y\n            width (int): region width\n            height (int): region height\n\n        Returns:\n            Image: The screenshot Image object\n        \"\"\"\n        screen_w, screen_h = self._fix_display_size()\n        x = x or 0\n        y = y or 0\n        width = width or screen_w\n        height = height or screen_h\n        img = self.screenshot(region=(x, y, width, height))\n        return img\n\n    def save_screenshot(self, path):\n\"\"\"\n        Saves a screenshot in a given path.\n\n        Args:\n            path (str): The filepath in which to save the screenshot\n\n        \"\"\"\n        self.screenshot(path)\n\n    def get_element_coords(self, label, x=None, y=None, width=None, height=None, matching=0.9, best=True):\n\"\"\"\n        Find an element defined by label on screen and returns its coordinates.\n\n        Args:\n            label (str): The image identifier\n            x (int, optional): X (Left) coordinate of the search area.\n            y (int, optional): Y (Top) coordinate of the search area.\n            width (int, optional): Width of the search area.\n            height (int, optional): Height of the search area.\n            matching (float, optional): Minimum score to consider a match in the element image recognition process.\n                Defaults to 0.9.\n            best (bool, optional): Whether or not to search for the best value. If False the method returns on\n                the first find. Defaults to True.\n\n        Returns:\n            coords (Tuple): A tuple containing the x and y coordinates for the element.\n        \"\"\"\n        self.state.element = None\n        screen_w, screen_h = self._fix_display_size()\n        x = x or 0\n        y = y or 0\n        width = width or screen_w\n        height = height or screen_h\n        region = (x, y, width, height)\n\n        if not best:\n            print('Warning: Ignoring best=False for now. It will be supported in the future.')\n\n        element_path = self._search_image_file(label)\n        element_path = self._image_path_as_image(element_path)\n\n        haystack = self.get_screenshot()\n        it = cv2find.locate_all_opencv(element_path, haystack_image=haystack,\n                                       region=region, confidence=matching, grayscale=False)\n        try:\n            ele = next(it)\n        except StopIteration:\n            ele = None\n\n        if ele is None:\n            return None, None\n        ele = self._fix_retina_element(ele)\n        self.state.element = ele\n        return ele.left, ele.top\n\n    def get_element_coords_centered(self, label, x=None, y=None, width=None, height=None,\n                                    matching=0.9, best=True):\n\"\"\"\n        Find an element defined by label on screen and returns its centered coordinates.\n\n        Args:\n            label (str): The image identifier\n            x (int, optional): X (Left) coordinate of the search area.\n            y (int, optional): Y (Top) coordinate of the search area.\n            width (int, optional): Width of the search area.\n            height (int, optional): Height of the search area.\n            matching (float, optional): Minimum score to consider a match in the element image recognition process.\n                Defaults to 0.9.\n            best (bool, optional): Whether or not to search for the best value. If False the method returns on\n                the first find. Defaults to True.\n\n        Returns:\n            coords (Tuple): A tuple containing the x and y coordinates for the center of the element.\n        \"\"\"\n        self.get_element_coords(label, x, y, width, height, matching, best)\n        return self.state.center()\n\n    #########\n    # Browser\n    #########\n\n    def browse(self, url, location=0):\n\"\"\"\n        Invoke the default browser passing an URL\n\n        Args:\n            url (str):  The URL to be visited.\n            location (int): If possible, open url in a location determined by new:\n                            * 0: the same browser window (the default)\n                            * 1: a new browser window\n                            * 2: a new browser page (\"tab\")\n\n        Returns:\n            bool: Whether or not the request was successful\n        \"\"\"\n        status = webbrowser.open(url, location)\n        return status\n\n    #######\n    # Mouse\n    #######\n\n    def click_on(self, label):\n\"\"\"\n        Click on the element.\n\n        Args:\n            label (str): The image identifier\n        \"\"\"\n        x, y = self.get_element_coords_centered(label)\n        if None in (x, y):\n            raise ValueError(f'Element not available. Cannot find {label}.')\n        _mouse_click(self._mouse_controller, x, y)\n\n    def get_last_x(self):\n\"\"\"\n        Get the last X position for the mouse.\n\n        Returns:\n            x (int): The last x position for the mouse.\n        \"\"\"\n        return self._mouse_controller.position[0]\n\n    def get_last_y(self):\n\"\"\"\n        Get the last Y position for the mouse.\n\n        Returns:\n            y (int): The last y position for the mouse.\n        \"\"\"\n        return self._mouse_controller.position[1]\n\n    def mouse_move(self, x, y):\n\"\"\"\n        Move the mouse to the coordinate defined by x and y\n\n        Args:\n            x (int): The X coordinate\n            y (int): The Y coordinate\n\n        \"\"\"\n        self._mouse_controller.position = (x, y)\n        self.sleep(config.DEFAULT_SLEEP_AFTER_ACTION)\n\n    def click_at(self, x, y):\n\"\"\"\n        Click at the coordinate defined by x and y\n\n        Args:\n            x (int): The X coordinate\n            y (int): The Y coordinate\n        \"\"\"\n        _mouse_click(self._mouse_controller, x, y)\n\n    @only_if_element\n    def click(self, wait_after=config.DEFAULT_SLEEP_AFTER_ACTION, *,\n              clicks=1, interval_between_clicks=0, button='left'):\n\"\"\"\n        Click on the last found element.\n\n        Args:\n            wait_after (int, optional): Interval to wait after clicking on the element.\n            clicks (int, optional): Number of times to click. Defaults to 1.\n            interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0.\n            button (str, optional): One of 'left', 'right', 'middle'. Defaults to 'left'\n        \"\"\"\n        x, y = self.state.center()\n        _mouse_click(self._mouse_controller, x, y, clicks, interval_between_clicks, button)\n        self.sleep(wait_after)\n\n    @only_if_element\n    def click_relative(self, x, y, wait_after=config.DEFAULT_SLEEP_AFTER_ACTION, *,\n                       clicks=1, interval_between_clicks=0, button='left'):\n\"\"\"\n        Click Relative on the last found element.\n\n        Args:\n            x (int): Horizontal offset\n            y (int): Vertical offset\n            wait_after (int, optional): Interval to wait after clicking on the element.\n            clicks (int, optional): Number of times to click. Defaults to 1.\n            interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0.\n            button (str, optional): One of 'left', 'right', 'middle'. Defaults to 'left'\n        \"\"\"\n        x = self.state.x() + x\n        y = self.state.y() + y\n        _mouse_click(self._mouse_controller, x, y, clicks, interval_between_clicks, button)\n        self.sleep(wait_after)\n\n    @only_if_element\n    def double_click(self, wait_after=config.DEFAULT_SLEEP_AFTER_ACTION):\n\"\"\"\n        Double Click on the last found element.\n\n        Args:\n            wait_after (int, optional): Interval to wait after clicking on the element.\n        \"\"\"\n        self.click(wait_after=wait_after, clicks=2)\n\n    @only_if_element\n    def double_click_relative(self, x, y, interval_between_clicks=0, wait_after=config.DEFAULT_SLEEP_AFTER_ACTION):\n\"\"\"\n        Double Click Relative on the last found element.\n\n        Args:\n            x (int): Horizontal offset\n            y (int): Vertical offset\n            interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0.\n            wait_after (int, optional): Interval to wait after clicking on the element.\n\n        \"\"\"\n        self.click_relative(x, y, wait_after=wait_after, clicks=2, interval_between_clicks=interval_between_clicks)\n\n    @only_if_element\n    def triple_click(self, wait_after=config.DEFAULT_SLEEP_AFTER_ACTION):\n\"\"\"\n        Triple Click on the last found element.\n\n        Args:\n            wait_after (int, optional): Interval to wait after clicking on the element.\n        \"\"\"\n        self.click(wait_after=wait_after, clicks=3)\n\n    @only_if_element\n    def triple_click_relative(self, x, y, interval_between_clicks=0, wait_after=config.DEFAULT_SLEEP_AFTER_ACTION):\n\"\"\"\n        Triple Click Relative on the last found element.\n\n        Args:\n            x (int): Horizontal offset\n            y (int): Vertical offset\n            interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0.\n            wait_after (int, optional): Interval to wait after clicking on the element.\n\n        \"\"\"\n        self.click_relative(x, y, wait_after=wait_after, clicks=3, interval_between_clicks=interval_between_clicks)\n\n    def mouse_down(self, wait_after=config.DEFAULT_SLEEP_AFTER_ACTION, *, button='left'):\n\"\"\"\n        Holds down the requested mouse button.\n\n        Args:\n            wait_after (int, optional): Interval to wait after clicking on the element.\n            button (str, optional): One of 'left', 'right', 'middle'. Defaults to 'left'\n        \"\"\"\n        mouse_button = mouse_map.get(button, None)\n        self._mouse_controller.press(mouse_button)\n        self.sleep(wait_after)\n\n    def mouse_up(self, wait_after=config.DEFAULT_SLEEP_AFTER_ACTION, *, button='left'):\n\"\"\"\n        Releases the requested mouse button.\n\n        Args:\n            wait_after (int, optional): Interval to wait after clicking on the element.\n            button (str, optional): One of 'left', 'right', 'middle'. Defaults to 'left'\n        \"\"\"\n        mouse_button = mouse_map.get(button, None)\n        self._mouse_controller.release(mouse_button)\n        self.sleep(wait_after)\n\n    def scroll_down(self, clicks):\n\"\"\"\n        Scroll Down n clicks\n\n        Args:\n            clicks (int): Number of times to scroll down.\n        \"\"\"\n        self._mouse_controller.scroll(0, -1 * clicks)\n        self.sleep(config.DEFAULT_SLEEP_AFTER_ACTION)\n\n    def scroll_up(self, clicks):\n\"\"\"\n        Scroll Up n clicks\n\n        Args:\n            clicks (int): Number of times to scroll up.\n        \"\"\"\n        self._mouse_controller.scroll(0, clicks)\n        self.sleep(config.DEFAULT_SLEEP_AFTER_ACTION)\n\n    @only_if_element\n    def move(self):\n\"\"\"\n        Move to the center position of last found item.\n        \"\"\"\n        x, y = self.state.center()\n        self._mouse_controller.position = (x, y)\n        self.sleep(config.DEFAULT_SLEEP_AFTER_ACTION)\n\n    def move_relative(self, x, y):\n\"\"\"\n        Move the mouse relative to its current position.\n\n        Args:\n            x (int): Horizontal offset\n            y (int): Vertical offset\n\n        \"\"\"\n        x = self.get_last_x() + x\n        y = self.get_last_y() + y\n        self._mouse_controller.position = (x, y)\n        self.sleep(config.DEFAULT_SLEEP_AFTER_ACTION)\n\n    def move_random(self, range_x, range_y):\n\"\"\"\n        Move randomly along the given x, y range.\n\n        Args:\n            range_x (int): Horizontal range\n            range_y (int): Vertical range\n\n        \"\"\"\n        x = int(random.random() * range_x)\n        y = int(random.random() * range_y)\n        self._mouse_controller.position = (x, y)\n        self.sleep(config.DEFAULT_SLEEP_AFTER_ACTION)\n\n    @only_if_element\n    def right_click(self, wait_after=config.DEFAULT_SLEEP_AFTER_ACTION, *,\n                    clicks=1, interval_between_clicks=0):\n\"\"\"\n        Right click on the last found element.\n\n        Args:\n            wait_after (int, optional): Interval to wait after clicking on the element.\n            clicks (int, optional): Number of times to click. Defaults to 1.\n            interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0.\n        \"\"\"\n        x, y = self.state.center()\n        _mouse_click(self._mouse_controller, x, y, clicks, interval_between_clicks, button='right')\n        self.sleep(wait_after)\n\n    def right_click_at(self, x, y):\n\"\"\"\n        Right click at the coordinate defined by x and y\n\n        Args:\n            x (int): The X coordinate\n            y (int): The Y coordinate\n        \"\"\"\n        _mouse_click(self._mouse_controller, x, y, button='right')\n\n    @only_if_element\n    def right_click_relative(self, x, y, interval_between_clicks=0, wait_after=config.DEFAULT_SLEEP_AFTER_ACTION):\n\"\"\"\n        Right Click Relative on the last found element.\n\n        Args:\n            x (int): Horizontal offset\n            y (int): Vertical offset\n            interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0.\n            wait_after (int, optional): Interval to wait after clicking on the element.\n        \"\"\"\n        self.click_relative(x, y, wait_after=wait_after, clicks=1, interval_between_clicks=interval_between_clicks,\n                            button='right')\n\n    ##########\n    # Keyboard\n    ##########\n\n    def type_key(self, text, interval=0):\n\"\"\"\n        Type a text char by char (individual key events).\n\n        Args:\n            text (str): text to be typed.\n            interval (int, optional): interval (ms) between each key press. Defaults to 0\n\n        \"\"\"\n        self.kb_type(text=text, interval=interval)\n\n    def kb_type(self, text, interval=0):\n\"\"\"\n        Type a text char by char (individual key events).\n\n        Args:\n            text (str): text to be typed.\n            interval (int, optional): interval (ms) between each key press. Defaults to 0\n\n        \"\"\"\n        for char in text:\n            self._kb_controller.type(char)\n            self.sleep(interval)\n        self.sleep(config.DEFAULT_SLEEP_AFTER_ACTION)\n\n    def paste(self, text=None, wait=0):\n\"\"\"\n        Paste content from the clipboard.\n\n        Args:\n            text (str, optional): The text to be pasted. Defaults to None\n            wait (int, optional): Wait interval (ms) after task\n        \"\"\"\n        if text:\n            pyperclip.copy(text)\n        self.control_v()\n\n    def copy_to_clipboard(self, text, wait=0):\n\"\"\"\n        Copy content to the clipboard.\n\n        Args:\n            text (str): The text to be copied.\n            wait (int, optional): Wait interval (ms) after task\n        \"\"\"\n        pyperclip.copy(text)\n        delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n        self.sleep(delay)\n\n    def tab(self, wait=0, presses=1):\n\"\"\"\n        Press key Tab\n\n        Args:\n            wait (int, optional): Wait interval (ms) after task\n            presses (int, optional): Number of times to press the key. Defaults to 1.\n\n        \"\"\"\n        delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n        for i in range(presses):\n            self._kb_controller.tap(Key.tab)\n            self.sleep(delay)\n\n    def enter(self, wait=0, presses=1):\n\"\"\"\n        Press key Enter\n\n        Args:\n            wait (int, optional): Wait interval (ms) after task\n            presses (int, optional): Number of times to press the key. Defaults to 1.\n\n        \"\"\"\n        delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n        for i in range(presses):\n            self._kb_controller.tap(Key.enter)\n            self.sleep(delay)\n\n    def key_right(self, wait=0):\n\"\"\"\n        Press key Right\n\n        Args:\n            wait (int, optional): Wait interval (ms) after task\n\n        \"\"\"\n        self._kb_controller.tap(Key.right)\n        delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n        self.sleep(delay)\n\n    def key_enter(self, wait=0):\n\"\"\"\n        Press key Enter\n\n        Args:\n            wait (int, optional): Wait interval (ms) after task\n\n        \"\"\"\n        self.enter(wait)\n\n    def key_end(self, wait=0):\n\"\"\"\n        Press key End\n\n        Args:\n            wait (int, optional): Wait interval (ms) after task\n\n        \"\"\"\n        self._kb_controller.tap(Key.end)\n        delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n        self.sleep(delay)\n\n    def key_esc(self, wait=0):\n\"\"\"\n        Press key Esc\n\n        Args:\n            wait (int, optional): Wait interval (ms) after task\n\n        \"\"\"\n        self._kb_controller.tap(Key.esc)\n        delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n        self.sleep(delay)\n\n    def _key_fx(self, idx, wait=0):\n\"\"\"\n        Press key F[idx] where idx is a value from 1 to 12\n\n        Args:\n            idx (int): F key index from 1 to 12\n            wait (int, optional): Wait interval (ms) after task\n\n        \"\"\"\n        self._kb_controller.tap(idx)\n        delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n        self.sleep(delay)\n\n    def key_f1(self, wait=0):\n        self._key_fx(Key.f1, wait=wait)\n\n    def key_f2(self, wait=0):\n        self._key_fx(Key.f2, wait=wait)\n\n    def key_f3(self, wait=0):\n        self._key_fx(Key.f3, wait=wait)\n\n    def key_f4(self, wait=0):\n        self._key_fx(Key.f4, wait=wait)\n\n    def key_f5(self, wait=0):\n        self._key_fx(Key.f5, wait=wait)\n\n    def key_f6(self, wait=0):\n        self._key_fx(Key.f6, wait=wait)\n\n    def key_f7(self, wait=0):\n        self._key_fx(Key.f7, wait=wait)\n\n    def key_f8(self, wait=0):\n        self._key_fx(Key.f8, wait=wait)\n\n    def key_f9(self, wait=0):\n        self._key_fx(Key.f9, wait=wait)\n\n    def key_f10(self, wait=0):\n        self._key_fx(Key.f10, wait=wait)\n\n    def key_f11(self, wait=0):\n        self._key_fx(Key.f11, wait=wait)\n\n    def key_f12(self, wait=0):\n        self._key_fx(Key.f12, wait=wait)\n\n    def hold_shift(self, wait=0):\n\"\"\"\n        Hold key Shift\n\n        Args:\n            wait (int, optional): Wait interval (ms) after task\n\n        \"\"\"\n        self._kb_controller.press(Key.shift)\n        self.sleep(wait)\n\n    def release_shift(self):\n\"\"\"\n        Release key Shift.\n        This method needs to be invoked after holding Shift or similar.\n        \"\"\"\n        self._kb_controller.release(Key.shift)\n        self.sleep(config.DEFAULT_SLEEP_AFTER_ACTION)\n\n    def alt_space(self, wait=0):\n\"\"\"\n        Press keys Alt+Space\n\n        Args:\n            wait (int, optional): Wait interval (ms) after task\n\n        \"\"\"\n        with self._kb_controller.pressed(Key.alt):\n            self._kb_controller.tap(Key.space)\n        delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n        self.sleep(delay)\n\n    def maximize_window(self):\n\"\"\"\n        Shortcut to maximize window on Windows OS.\n        \"\"\"\n        with self._kb_controller.pressed(Key.alt, Key.space):\n            self._kb_controller.tap('x')\n        self.sleep(config.DEFAULT_SLEEP_AFTER_ACTION)\n\n    def type_keys_with_interval(self, interval, keys):\n\"\"\"\n        Press a sequence of keys. Hold the keys in the specific order and releases them.\n\n        Args:\n            interval (int): Interval (ms) in which to press and release keys\n            keys (list): List of keys to be pressed\n        \"\"\"\n        formatted_keys = []\n        for key in keys:\n            if len(key) &lt;= 1:\n                formatted_keys.append(key)\n                continue\n            key = key.lower()\n            key_value = keys_map.get(key, None)\n            if key_value:\n                formatted_keys.append(key_value)\n            elif key in Key._member_names_:\n                key_value = Key[key]\n                formatted_keys.append(key_value)\n\n        for key in formatted_keys:\n            self._kb_controller.press(key)\n            self.sleep(interval)\n        for key in reversed(formatted_keys):\n            self._kb_controller.release(key)\n            self.sleep(interval)\n\n    def type_keys(self, keys):\n\"\"\"\n        Press a sequence of keys. Hold the keys in the specific order and releases them.\n\n        Args:\n            keys (list): List of keys to be pressed\n        \"\"\"\n        self.type_keys_with_interval(100, keys)\n\n    def alt_e(self, wait=0):\n\"\"\"\n        Press keys Alt+E\n\n        Args:\n            wait (int, optional): Wait interval (ms) after task\n\n        \"\"\"\n        with self._kb_controller.pressed(Key.alt):\n            self._kb_controller.tap('e')\n        delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n        self.sleep(delay)\n\n    def alt_r(self, wait=0):\n\"\"\"\n        Press keys Alt+R\n\n        Args:\n            wait (int, optional): Wait interval (ms) after task\n\n        \"\"\"\n        with self._kb_controller.pressed(Key.alt):\n            self._kb_controller.tap('r')\n        delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n        self.sleep(delay)\n\n    def alt_f(self, wait=0):\n\"\"\"\n        Press keys Alt+F\n\n        Args:\n            wait (int, optional): Wait interval (ms) after task\n\n        \"\"\"\n        with self._kb_controller.pressed(Key.alt):\n            self._kb_controller.tap('f')\n        delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n        self.sleep(delay)\n\n    def alt_u(self, wait=0):\n\"\"\"\n        Press keys Alt+U\n\n        Args:\n            wait (int, optional): Wait interval (ms) after task\n\n        \"\"\"\n        with self._kb_controller.pressed(Key.alt):\n            self._kb_controller.tap('u')\n        delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n        self.sleep(delay)\n\n    def alt_f4(self, wait=0):\n\"\"\"\n        Press keys Alt+F4\n\n        Args:\n            wait (int, optional): Wait interval (ms) after task\n\n        \"\"\"\n        with self._kb_controller.pressed(Key.alt):\n            self._kb_controller.tap(Key.f4)\n        delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n        self.sleep(delay)\n\n    def control_c(self, wait=0):\n\"\"\"\n        Press keys CTRL+C\n\n        Args:\n            wait (int, optional): Wait interval (ms) after task\n\n        \"\"\"\n        self.control_key(key_to_press='c', wait=wait)\n        return self.get_clipboard()\n\n    def control_v(self, wait=0):\n\"\"\"\n        Press keys CTRL+V\n\n        Args:\n            wait (int, optional): Wait interval (ms) after task\n\n        \"\"\"\n        self.control_key(key_to_press='v', wait=wait)\n\n    def control_a(self, wait=0):\n\"\"\"\n        Press keys CTRL+A\n\n        Args:\n            wait (int, optional): Wait interval (ms) after task\n\n        \"\"\"\n        self.control_key(key_to_press='a', wait=wait)\n\n    def control_f(self, wait=0):\n\"\"\"\n        Press keys CTRL+F\n\n        Args:\n            wait (int, optional): Wait interval (ms) after task\n\n        \"\"\"\n        self.control_key(key_to_press='f', wait=wait)\n\n    def control_p(self, wait=0):\n\"\"\"\n        Press keys CTRL+P\n\n        Args:\n            wait (int, optional): Wait interval (ms) after task\n\n        \"\"\"\n        self.control_key(key_to_press='p', wait=wait)\n\n    def control_u(self, wait=0):\n\"\"\"\n        Press keys CTRL+U\n\n        Args:\n            wait (int, optional): Wait interval (ms) after task\n\n        \"\"\"\n        self.control_key(key_to_press='u', wait=wait)\n\n    def control_r(self, wait=0):\n\"\"\"\n        Press keys CTRL+R\n\n        Args:\n            wait (int, optional): Wait interval (ms) after task\n\n        \"\"\"\n        self.control_key(key_to_press='r', wait=wait)\n\n    def control_t(self, wait=0):\n\"\"\"\n        Press keys CTRL+T\n\n        Args:\n            wait (int, optional): Wait interval (ms) after task\n\n        \"\"\"\n        self.control_key(key_to_press='t', wait=wait)\n\n    def control_s(self, wait=0):\n\"\"\"\n        Press keys CTRL+S\n\n        Args:\n            wait (int, optional): Wait interval (ms) after task\n\n        \"\"\"\n        self.control_key(key_to_press='s', wait=wait)\n\n    def control_key(self, key_to_press: Union[str, Key], wait=0):\n\"\"\"\n        Press CTRL and one more simple key to perform a keyboard shortcut\n\n        Args:\n            key_to_press (str): The key that will be pressed with the CTRL.\n            wait (int, optional): Wait interval (ms) after task.\n\n        \"\"\"\n        if isinstance(key_to_press, str):\n            key_to_press = key_to_press.lower()\n\n        key = Key.ctrl\n        if platform.system() == 'Darwin':\n            key = Key.cmd\n        with self._kb_controller.pressed(key):\n            self._kb_controller.tap(key_to_press)\n        delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n        self.sleep(delay)\n\n    def control_end(self, wait=0):\n\"\"\"\n        Press keys CTRL+End\n\n        Args:\n            wait (int, optional): Wait interval (ms) after task\n\n        \"\"\"\n        self.control_key(key_to_press=Key.end, wait=wait)\n\n    def control_home(self, wait=0):\n\"\"\"\n        Press keys CTRL+Home\n\n        Args:\n            wait (int, optional): Wait interval (ms) after task\n\n        \"\"\"\n        self.control_key(key_to_press=Key.home, wait=wait)\n\n    def control_w(self, wait=0):\n\"\"\"\n        Press keys CTRL+W\n\n        Args:\n            wait (int, optional): Wait interval (ms) after task\n\n        \"\"\"\n        self.control_key(key_to_press='w', wait=wait)\n\n    def control_shift_p(self, wait=0):\n\"\"\"\n        Press keys CTRL+Shift+P\n\n        Args:\n            wait (int, optional): Wait interval (ms) after task\n\n        \"\"\"\n        key_ctrl = Key.ctrl\n        if platform.system() == 'Darwin':\n            key_ctrl = Key.cmd\n        with self._kb_controller.pressed(key_ctrl, Key.shift):\n            self._kb_controller.tap('p')\n        delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n        self.sleep(delay)\n\n    def control_shift_j(self, wait=0):\n\"\"\"\n        Press keys CTRL+Shift+J\n\n        Args:\n            wait (int, optional): Wait interval (ms) after task\n\n        \"\"\"\n        key_ctrl = Key.ctrl\n        if platform.system() == 'Darwin':\n            key_ctrl = Key.cmd\n        with self._kb_controller.pressed(key_ctrl, Key.shift):\n            self._kb_controller.tap('j')\n        delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n        self.sleep(delay)\n\n    def shift_tab(self, wait=0):\n\"\"\"\n        Press keys Shift+Tab\n\n        Args:\n            wait (int, optional): Wait interval (ms) after task\n\n        \"\"\"\n        with self._kb_controller.pressed(Key.shift):\n            self._kb_controller.tap(Key.tab)\n        delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n        self.sleep(delay)\n\n    def get_clipboard(self):\n\"\"\"\n        Get the current content in the clipboard.\n\n        Returns:\n            text (str): Current clipboard content\n        \"\"\"\n        return pyperclip.paste()\n\n    def type_left(self, wait=0):\n\"\"\"\n        Press Left key\n\n        Args:\n            wait (int, optional): Wait interval (ms) after task\n\n        \"\"\"\n        self._kb_controller.tap(Key.left)\n        delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n        self.sleep(delay)\n\n    def type_right(self, wait=0):\n\"\"\"\n        Press Right key\n\n        Args:\n            wait (int, optional): Wait interval (ms) after task\n\n        \"\"\"\n        self._kb_controller.tap(Key.right)\n        delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n        self.sleep(delay)\n\n    def type_down(self, wait=0):\n\"\"\"\n        Press Down key\n\n        Args:\n            wait (int, optional): Wait interval (ms) after task\n\n        \"\"\"\n        self._kb_controller.tap(Key.down)\n        delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n        self.sleep(delay)\n\n    def type_up(self, wait=0):\n\"\"\"\n        Press Up key\n\n        Args:\n            wait (int, optional): Wait interval (ms) after task\n\n        \"\"\"\n        self._kb_controller.tap(Key.up)\n        delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n        self.sleep(delay)\n\n    def type_windows(self, wait=0):\n\"\"\"\n        Press Win logo key\n\n        Args:\n            wait (int, optional): Wait interval (ms) after task\n\n        \"\"\"\n        self._kb_controller.tap(Key.cmd)\n        delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n        self.sleep(delay)\n\n    def page_up(self, wait=0):\n\"\"\"\n        Press Page Up key\n\n        Args:\n            wait (int, optional): Wait interval (ms) after task\n\n        \"\"\"\n        self._kb_controller.tap(Key.page_up)\n        delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n        self.sleep(delay)\n\n    def page_down(self, wait=0):\n\"\"\"\n        Press Page Down key\n\n        Args:\n            wait (int, optional): Wait interval (ms) after task\n\n        \"\"\"\n        self._kb_controller.tap(Key.page_down)\n        delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n        self.sleep(delay)\n\n    def space(self, wait=0):\n\"\"\"\n        Press Space key\n\n        Args:\n            wait (int, optional): Wait interval (ms) after task\n\n        \"\"\"\n        self._kb_controller.tap(Key.space)\n        delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n        self.sleep(delay)\n\n    def backspace(self, wait=0):\n\"\"\"\n        Press Backspace key\n\n        Args:\n            wait (int, optional): Wait interval (ms) after task\n\n        \"\"\"\n        self._kb_controller.tap(Key.backspace)\n        delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n        self.sleep(delay)\n\n    def delete(self, wait=0):\n\"\"\"\n        Press Delete key\n\n        Args:\n            wait (int, optional): Wait interval (ms) after task\n\n        \"\"\"\n        self._kb_controller.tap(Key.delete)\n        delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n        self.sleep(delay)\n\n    ######\n    # Misc\n    ######\n\n    def wait_for_file(self, path, timeout=10000):\n\"\"\"\n        Invoke the system handler to open the given file.\n\n        Args:\n            path (str): The path for the file to be executed\n            timeout (int, optional): Maximum wait time (ms) to search for a hit.\n                Defaults to 10000ms (10s).\n\n        Returns\n            status (bool): Whether or not the file was available before the timeout\n        \"\"\"\n        start_time = time.time()\n\n        while True:\n            elapsed_time = (time.time() - start_time) * 1000\n            if elapsed_time &gt; timeout:\n                return False\n            if os.path.isfile(path) and os.access(path, os.R_OK):\n                return True\n            self.sleep(config.DEFAULT_SLEEP_AFTER_ACTION)\n\n    def execute(self, file_path):\n\"\"\"\n        Invoke the system handler to open the given file.\n\n        Args:\n            file_path (str): The path for the file to be executed\n        \"\"\"\n        if platform.system() == \"Windows\":\n            os.startfile(file_path)\n        else:\n            subprocess.Popen(file_path.split(\" \"))\n\n    def wait(self, interval):\n\"\"\"\n        Wait / Sleep for a given interval.\n\n        Args:\n            interval (int): Interval in milliseconds\n\n        \"\"\"\n        time.sleep(interval / 1000.0)\n\n    def sleep(self, interval):\n\"\"\"\n        Wait / Sleep for a given interval.\n\n        Args:\n            interval (int): Interval in milliseconds\n\n        \"\"\"\n        self.wait(interval)\n\n    #############\n    # Application\n    #############\n\n    @if_windows_os\n    def connect_to_app(self, backend=Backend.WIN_32, timeout=60000, **connection_selectors) -&gt; 'Application':\n\"\"\"\n        Connects to an instance of an open application.\n        Use this method to be able to access application windows and elements.\n\n        Args:\n            backend (Backend, optional): The accessibility technology defined in the Backend class\n                that could be used for your application. Defaults to Backend.WIN_32 ('win32').\n            timeout (int, optional): Maximum wait time (ms) to wait for connection.\n                Defaults to 60000ms (60s).\n            **connection_selectors: Attributes that can be used to connect to an application.\n                [See more details about the available selectors\\\n                ](https://documentation.botcity.dev/frameworks/desktop/windows-apps/).\n\n        Returns\n            app (Application): The Application instance.\n        \"\"\"\n        self.app = connect(backend, timeout, **connection_selectors)\n        return self.app\n\n    @if_app_connected\n    def find_app_window(self, waiting_time=10000, **selectors) -&gt; 'WindowSpecification':\n\"\"\"\n        Find a window of the currently connected application using the available selectors.\n\n        Args:\n            waiting_time (int, optional): Maximum wait time (ms) to search for a hit.\n                Defaults to 10000ms (10s).\n            **selectors: Attributes that can be used to filter an element.\n                [See more details about the available selectors\\\n                ](https://documentation.botcity.dev/frameworks/desktop/windows-apps/).\n\n        Returns\n            dialog (WindowSpecification): The window or control found.\n        \"\"\"\n        dialog = find_window(self.app, waiting_time, **selectors)\n        return dialog\n\n    @if_app_connected\n    def find_app_element(self, from_parent_window: 'WindowSpecification' = None,\n                         waiting_time=10000, **selectors) -&gt; 'WindowSpecification':\n\"\"\"\n        Find a element of the currently connected application using the available selectors.\n        You can pass the context window where the element is contained.\n\n        Args:\n            from_parent_window (WindowSpecification, optional): The element's parent window.\n            waiting_time (int, optional): Maximum wait time (ms) to search for a hit.\n                Defaults to 10000ms (10s).\n            **selectors: Attributes that can be used to filter an element.\n                [See more details about the available selectors\\\n                ](https://documentation.botcity.dev/frameworks/desktop/windows-apps/).\n\n        Returns\n            element (WindowSpecification): The element/control found.\n        \"\"\"\n        element = find_element(self.app, from_parent_window, waiting_time, **selectors)\n        return element\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.app","title":"<code>app</code>  <code>property</code> <code>writable</code>","text":"<p>The connected application instance to be used.</p> <p>Returns:</p> Name Type Description <code>app</code> <code>Application</code> <p>The connected Application instance.</p>"},{"location":"bot/#botcity.core.bot.DesktopBot.add_image","title":"<code>add_image(label, path)</code>","text":"<p>Add an image into the state image map.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The image identifier</p> required <code>path</code> <code>str</code> <p>The path for the image on disk</p> required Source code in <code>botcity/core/bot.py</code> <pre><code>def add_image(self, label, path):\n\"\"\"\n    Add an image into the state image map.\n\n    Args:\n        label (str): The image identifier\n        path (str): The path for the image on disk\n    \"\"\"\n    self.state.map_images[label] = path\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.alt_e","title":"<code>alt_e(wait=0)</code>","text":"<p>Press keys Alt+E</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>int</code> <p>Wait interval (ms) after task</p> <code>0</code> Source code in <code>botcity/core/bot.py</code> <pre><code>def alt_e(self, wait=0):\n\"\"\"\n    Press keys Alt+E\n\n    Args:\n        wait (int, optional): Wait interval (ms) after task\n\n    \"\"\"\n    with self._kb_controller.pressed(Key.alt):\n        self._kb_controller.tap('e')\n    delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n    self.sleep(delay)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.alt_f","title":"<code>alt_f(wait=0)</code>","text":"<p>Press keys Alt+F</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>int</code> <p>Wait interval (ms) after task</p> <code>0</code> Source code in <code>botcity/core/bot.py</code> <pre><code>def alt_f(self, wait=0):\n\"\"\"\n    Press keys Alt+F\n\n    Args:\n        wait (int, optional): Wait interval (ms) after task\n\n    \"\"\"\n    with self._kb_controller.pressed(Key.alt):\n        self._kb_controller.tap('f')\n    delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n    self.sleep(delay)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.alt_f4","title":"<code>alt_f4(wait=0)</code>","text":"<p>Press keys Alt+F4</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>int</code> <p>Wait interval (ms) after task</p> <code>0</code> Source code in <code>botcity/core/bot.py</code> <pre><code>def alt_f4(self, wait=0):\n\"\"\"\n    Press keys Alt+F4\n\n    Args:\n        wait (int, optional): Wait interval (ms) after task\n\n    \"\"\"\n    with self._kb_controller.pressed(Key.alt):\n        self._kb_controller.tap(Key.f4)\n    delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n    self.sleep(delay)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.alt_r","title":"<code>alt_r(wait=0)</code>","text":"<p>Press keys Alt+R</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>int</code> <p>Wait interval (ms) after task</p> <code>0</code> Source code in <code>botcity/core/bot.py</code> <pre><code>def alt_r(self, wait=0):\n\"\"\"\n    Press keys Alt+R\n\n    Args:\n        wait (int, optional): Wait interval (ms) after task\n\n    \"\"\"\n    with self._kb_controller.pressed(Key.alt):\n        self._kb_controller.tap('r')\n    delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n    self.sleep(delay)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.alt_space","title":"<code>alt_space(wait=0)</code>","text":"<p>Press keys Alt+Space</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>int</code> <p>Wait interval (ms) after task</p> <code>0</code> Source code in <code>botcity/core/bot.py</code> <pre><code>def alt_space(self, wait=0):\n\"\"\"\n    Press keys Alt+Space\n\n    Args:\n        wait (int, optional): Wait interval (ms) after task\n\n    \"\"\"\n    with self._kb_controller.pressed(Key.alt):\n        self._kb_controller.tap(Key.space)\n    delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n    self.sleep(delay)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.alt_u","title":"<code>alt_u(wait=0)</code>","text":"<p>Press keys Alt+U</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>int</code> <p>Wait interval (ms) after task</p> <code>0</code> Source code in <code>botcity/core/bot.py</code> <pre><code>def alt_u(self, wait=0):\n\"\"\"\n    Press keys Alt+U\n\n    Args:\n        wait (int, optional): Wait interval (ms) after task\n\n    \"\"\"\n    with self._kb_controller.pressed(Key.alt):\n        self._kb_controller.tap('u')\n    delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n    self.sleep(delay)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.backspace","title":"<code>backspace(wait=0)</code>","text":"<p>Press Backspace key</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>int</code> <p>Wait interval (ms) after task</p> <code>0</code> Source code in <code>botcity/core/bot.py</code> <pre><code>def backspace(self, wait=0):\n\"\"\"\n    Press Backspace key\n\n    Args:\n        wait (int, optional): Wait interval (ms) after task\n\n    \"\"\"\n    self._kb_controller.tap(Key.backspace)\n    delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n    self.sleep(delay)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.browse","title":"<code>browse(url, location=0)</code>","text":"<p>Invoke the default browser passing an URL</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL to be visited.</p> required <code>location</code> <code>int</code> <p>If possible, open url in a location determined by new:             * 0: the same browser window (the default)             * 1: a new browser window             * 2: a new browser page (\"tab\")</p> <code>0</code> <p>Returns:</p> Name Type Description <code>bool</code> <p>Whether or not the request was successful</p> Source code in <code>botcity/core/bot.py</code> <pre><code>def browse(self, url, location=0):\n\"\"\"\n    Invoke the default browser passing an URL\n\n    Args:\n        url (str):  The URL to be visited.\n        location (int): If possible, open url in a location determined by new:\n                        * 0: the same browser window (the default)\n                        * 1: a new browser window\n                        * 2: a new browser page (\"tab\")\n\n    Returns:\n        bool: Whether or not the request was successful\n    \"\"\"\n    status = webbrowser.open(url, location)\n    return status\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.click","title":"<code>click(wait_after=config.DEFAULT_SLEEP_AFTER_ACTION, *, clicks=1, interval_between_clicks=0, button='left')</code>","text":"<p>Click on the last found element.</p> <p>Parameters:</p> Name Type Description Default <code>wait_after</code> <code>int</code> <p>Interval to wait after clicking on the element.</p> <code>config.DEFAULT_SLEEP_AFTER_ACTION</code> <code>clicks</code> <code>int</code> <p>Number of times to click. Defaults to 1.</p> <code>1</code> <code>interval_between_clicks</code> <code>int</code> <p>The interval between clicks in ms. Defaults to 0.</p> <code>0</code> <code>button</code> <code>str</code> <p>One of 'left', 'right', 'middle'. Defaults to 'left'</p> <code>'left'</code> Source code in <code>botcity/core/bot.py</code> <pre><code>@only_if_element\ndef click(self, wait_after=config.DEFAULT_SLEEP_AFTER_ACTION, *,\n          clicks=1, interval_between_clicks=0, button='left'):\n\"\"\"\n    Click on the last found element.\n\n    Args:\n        wait_after (int, optional): Interval to wait after clicking on the element.\n        clicks (int, optional): Number of times to click. Defaults to 1.\n        interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0.\n        button (str, optional): One of 'left', 'right', 'middle'. Defaults to 'left'\n    \"\"\"\n    x, y = self.state.center()\n    _mouse_click(self._mouse_controller, x, y, clicks, interval_between_clicks, button)\n    self.sleep(wait_after)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.click_at","title":"<code>click_at(x, y)</code>","text":"<p>Click at the coordinate defined by x and y</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>The X coordinate</p> required <code>y</code> <code>int</code> <p>The Y coordinate</p> required Source code in <code>botcity/core/bot.py</code> <pre><code>def click_at(self, x, y):\n\"\"\"\n    Click at the coordinate defined by x and y\n\n    Args:\n        x (int): The X coordinate\n        y (int): The Y coordinate\n    \"\"\"\n    _mouse_click(self._mouse_controller, x, y)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.click_on","title":"<code>click_on(label)</code>","text":"<p>Click on the element.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The image identifier</p> required Source code in <code>botcity/core/bot.py</code> <pre><code>def click_on(self, label):\n\"\"\"\n    Click on the element.\n\n    Args:\n        label (str): The image identifier\n    \"\"\"\n    x, y = self.get_element_coords_centered(label)\n    if None in (x, y):\n        raise ValueError(f'Element not available. Cannot find {label}.')\n    _mouse_click(self._mouse_controller, x, y)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.click_relative","title":"<code>click_relative(x, y, wait_after=config.DEFAULT_SLEEP_AFTER_ACTION, *, clicks=1, interval_between_clicks=0, button='left')</code>","text":"<p>Click Relative on the last found element.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>Horizontal offset</p> required <code>y</code> <code>int</code> <p>Vertical offset</p> required <code>wait_after</code> <code>int</code> <p>Interval to wait after clicking on the element.</p> <code>config.DEFAULT_SLEEP_AFTER_ACTION</code> <code>clicks</code> <code>int</code> <p>Number of times to click. Defaults to 1.</p> <code>1</code> <code>interval_between_clicks</code> <code>int</code> <p>The interval between clicks in ms. Defaults to 0.</p> <code>0</code> <code>button</code> <code>str</code> <p>One of 'left', 'right', 'middle'. Defaults to 'left'</p> <code>'left'</code> Source code in <code>botcity/core/bot.py</code> <pre><code>@only_if_element\ndef click_relative(self, x, y, wait_after=config.DEFAULT_SLEEP_AFTER_ACTION, *,\n                   clicks=1, interval_between_clicks=0, button='left'):\n\"\"\"\n    Click Relative on the last found element.\n\n    Args:\n        x (int): Horizontal offset\n        y (int): Vertical offset\n        wait_after (int, optional): Interval to wait after clicking on the element.\n        clicks (int, optional): Number of times to click. Defaults to 1.\n        interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0.\n        button (str, optional): One of 'left', 'right', 'middle'. Defaults to 'left'\n    \"\"\"\n    x = self.state.x() + x\n    y = self.state.y() + y\n    _mouse_click(self._mouse_controller, x, y, clicks, interval_between_clicks, button)\n    self.sleep(wait_after)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.connect_to_app","title":"<code>connect_to_app(backend=Backend.WIN_32, timeout=60000, **connection_selectors)</code>","text":"<p>Connects to an instance of an open application. Use this method to be able to access application windows and elements.</p> <p>Parameters:</p> Name Type Description Default <code>backend</code> <code>Backend</code> <p>The accessibility technology defined in the Backend class that could be used for your application. Defaults to Backend.WIN_32 ('win32').</p> <code>Backend.WIN_32</code> <code>timeout</code> <code>int</code> <p>Maximum wait time (ms) to wait for connection. Defaults to 60000ms (60s).</p> <code>60000</code> <code>**connection_selectors</code> <p>Attributes that can be used to connect to an application. See more details about the available selectors                .</p> <code>{}</code> <p>Returns     app (Application): The Application instance.</p> Source code in <code>botcity/core/bot.py</code> <pre><code>@if_windows_os\ndef connect_to_app(self, backend=Backend.WIN_32, timeout=60000, **connection_selectors) -&gt; 'Application':\n\"\"\"\n    Connects to an instance of an open application.\n    Use this method to be able to access application windows and elements.\n\n    Args:\n        backend (Backend, optional): The accessibility technology defined in the Backend class\n            that could be used for your application. Defaults to Backend.WIN_32 ('win32').\n        timeout (int, optional): Maximum wait time (ms) to wait for connection.\n            Defaults to 60000ms (60s).\n        **connection_selectors: Attributes that can be used to connect to an application.\n            [See more details about the available selectors\\\n            ](https://documentation.botcity.dev/frameworks/desktop/windows-apps/).\n\n    Returns\n        app (Application): The Application instance.\n    \"\"\"\n    self.app = connect(backend, timeout, **connection_selectors)\n    return self.app\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.control_a","title":"<code>control_a(wait=0)</code>","text":"<p>Press keys CTRL+A</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>int</code> <p>Wait interval (ms) after task</p> <code>0</code> Source code in <code>botcity/core/bot.py</code> <pre><code>def control_a(self, wait=0):\n\"\"\"\n    Press keys CTRL+A\n\n    Args:\n        wait (int, optional): Wait interval (ms) after task\n\n    \"\"\"\n    self.control_key(key_to_press='a', wait=wait)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.control_c","title":"<code>control_c(wait=0)</code>","text":"<p>Press keys CTRL+C</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>int</code> <p>Wait interval (ms) after task</p> <code>0</code> Source code in <code>botcity/core/bot.py</code> <pre><code>def control_c(self, wait=0):\n\"\"\"\n    Press keys CTRL+C\n\n    Args:\n        wait (int, optional): Wait interval (ms) after task\n\n    \"\"\"\n    self.control_key(key_to_press='c', wait=wait)\n    return self.get_clipboard()\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.control_end","title":"<code>control_end(wait=0)</code>","text":"<p>Press keys CTRL+End</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>int</code> <p>Wait interval (ms) after task</p> <code>0</code> Source code in <code>botcity/core/bot.py</code> <pre><code>def control_end(self, wait=0):\n\"\"\"\n    Press keys CTRL+End\n\n    Args:\n        wait (int, optional): Wait interval (ms) after task\n\n    \"\"\"\n    self.control_key(key_to_press=Key.end, wait=wait)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.control_f","title":"<code>control_f(wait=0)</code>","text":"<p>Press keys CTRL+F</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>int</code> <p>Wait interval (ms) after task</p> <code>0</code> Source code in <code>botcity/core/bot.py</code> <pre><code>def control_f(self, wait=0):\n\"\"\"\n    Press keys CTRL+F\n\n    Args:\n        wait (int, optional): Wait interval (ms) after task\n\n    \"\"\"\n    self.control_key(key_to_press='f', wait=wait)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.control_home","title":"<code>control_home(wait=0)</code>","text":"<p>Press keys CTRL+Home</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>int</code> <p>Wait interval (ms) after task</p> <code>0</code> Source code in <code>botcity/core/bot.py</code> <pre><code>def control_home(self, wait=0):\n\"\"\"\n    Press keys CTRL+Home\n\n    Args:\n        wait (int, optional): Wait interval (ms) after task\n\n    \"\"\"\n    self.control_key(key_to_press=Key.home, wait=wait)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.control_key","title":"<code>control_key(key_to_press, wait=0)</code>","text":"<p>Press CTRL and one more simple key to perform a keyboard shortcut</p> <p>Parameters:</p> Name Type Description Default <code>key_to_press</code> <code>str</code> <p>The key that will be pressed with the CTRL.</p> required <code>wait</code> <code>int</code> <p>Wait interval (ms) after task.</p> <code>0</code> Source code in <code>botcity/core/bot.py</code> <pre><code>def control_key(self, key_to_press: Union[str, Key], wait=0):\n\"\"\"\n    Press CTRL and one more simple key to perform a keyboard shortcut\n\n    Args:\n        key_to_press (str): The key that will be pressed with the CTRL.\n        wait (int, optional): Wait interval (ms) after task.\n\n    \"\"\"\n    if isinstance(key_to_press, str):\n        key_to_press = key_to_press.lower()\n\n    key = Key.ctrl\n    if platform.system() == 'Darwin':\n        key = Key.cmd\n    with self._kb_controller.pressed(key):\n        self._kb_controller.tap(key_to_press)\n    delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n    self.sleep(delay)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.control_p","title":"<code>control_p(wait=0)</code>","text":"<p>Press keys CTRL+P</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>int</code> <p>Wait interval (ms) after task</p> <code>0</code> Source code in <code>botcity/core/bot.py</code> <pre><code>def control_p(self, wait=0):\n\"\"\"\n    Press keys CTRL+P\n\n    Args:\n        wait (int, optional): Wait interval (ms) after task\n\n    \"\"\"\n    self.control_key(key_to_press='p', wait=wait)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.control_r","title":"<code>control_r(wait=0)</code>","text":"<p>Press keys CTRL+R</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>int</code> <p>Wait interval (ms) after task</p> <code>0</code> Source code in <code>botcity/core/bot.py</code> <pre><code>def control_r(self, wait=0):\n\"\"\"\n    Press keys CTRL+R\n\n    Args:\n        wait (int, optional): Wait interval (ms) after task\n\n    \"\"\"\n    self.control_key(key_to_press='r', wait=wait)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.control_s","title":"<code>control_s(wait=0)</code>","text":"<p>Press keys CTRL+S</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>int</code> <p>Wait interval (ms) after task</p> <code>0</code> Source code in <code>botcity/core/bot.py</code> <pre><code>def control_s(self, wait=0):\n\"\"\"\n    Press keys CTRL+S\n\n    Args:\n        wait (int, optional): Wait interval (ms) after task\n\n    \"\"\"\n    self.control_key(key_to_press='s', wait=wait)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.control_shift_j","title":"<code>control_shift_j(wait=0)</code>","text":"<p>Press keys CTRL+Shift+J</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>int</code> <p>Wait interval (ms) after task</p> <code>0</code> Source code in <code>botcity/core/bot.py</code> <pre><code>def control_shift_j(self, wait=0):\n\"\"\"\n    Press keys CTRL+Shift+J\n\n    Args:\n        wait (int, optional): Wait interval (ms) after task\n\n    \"\"\"\n    key_ctrl = Key.ctrl\n    if platform.system() == 'Darwin':\n        key_ctrl = Key.cmd\n    with self._kb_controller.pressed(key_ctrl, Key.shift):\n        self._kb_controller.tap('j')\n    delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n    self.sleep(delay)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.control_shift_p","title":"<code>control_shift_p(wait=0)</code>","text":"<p>Press keys CTRL+Shift+P</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>int</code> <p>Wait interval (ms) after task</p> <code>0</code> Source code in <code>botcity/core/bot.py</code> <pre><code>def control_shift_p(self, wait=0):\n\"\"\"\n    Press keys CTRL+Shift+P\n\n    Args:\n        wait (int, optional): Wait interval (ms) after task\n\n    \"\"\"\n    key_ctrl = Key.ctrl\n    if platform.system() == 'Darwin':\n        key_ctrl = Key.cmd\n    with self._kb_controller.pressed(key_ctrl, Key.shift):\n        self._kb_controller.tap('p')\n    delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n    self.sleep(delay)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.control_t","title":"<code>control_t(wait=0)</code>","text":"<p>Press keys CTRL+T</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>int</code> <p>Wait interval (ms) after task</p> <code>0</code> Source code in <code>botcity/core/bot.py</code> <pre><code>def control_t(self, wait=0):\n\"\"\"\n    Press keys CTRL+T\n\n    Args:\n        wait (int, optional): Wait interval (ms) after task\n\n    \"\"\"\n    self.control_key(key_to_press='t', wait=wait)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.control_u","title":"<code>control_u(wait=0)</code>","text":"<p>Press keys CTRL+U</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>int</code> <p>Wait interval (ms) after task</p> <code>0</code> Source code in <code>botcity/core/bot.py</code> <pre><code>def control_u(self, wait=0):\n\"\"\"\n    Press keys CTRL+U\n\n    Args:\n        wait (int, optional): Wait interval (ms) after task\n\n    \"\"\"\n    self.control_key(key_to_press='u', wait=wait)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.control_v","title":"<code>control_v(wait=0)</code>","text":"<p>Press keys CTRL+V</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>int</code> <p>Wait interval (ms) after task</p> <code>0</code> Source code in <code>botcity/core/bot.py</code> <pre><code>def control_v(self, wait=0):\n\"\"\"\n    Press keys CTRL+V\n\n    Args:\n        wait (int, optional): Wait interval (ms) after task\n\n    \"\"\"\n    self.control_key(key_to_press='v', wait=wait)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.control_w","title":"<code>control_w(wait=0)</code>","text":"<p>Press keys CTRL+W</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>int</code> <p>Wait interval (ms) after task</p> <code>0</code> Source code in <code>botcity/core/bot.py</code> <pre><code>def control_w(self, wait=0):\n\"\"\"\n    Press keys CTRL+W\n\n    Args:\n        wait (int, optional): Wait interval (ms) after task\n\n    \"\"\"\n    self.control_key(key_to_press='w', wait=wait)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.copy_to_clipboard","title":"<code>copy_to_clipboard(text, wait=0)</code>","text":"<p>Copy content to the clipboard.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text to be copied.</p> required <code>wait</code> <code>int</code> <p>Wait interval (ms) after task</p> <code>0</code> Source code in <code>botcity/core/bot.py</code> <pre><code>def copy_to_clipboard(self, text, wait=0):\n\"\"\"\n    Copy content to the clipboard.\n\n    Args:\n        text (str): The text to be copied.\n        wait (int, optional): Wait interval (ms) after task\n    \"\"\"\n    pyperclip.copy(text)\n    delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n    self.sleep(delay)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.delete","title":"<code>delete(wait=0)</code>","text":"<p>Press Delete key</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>int</code> <p>Wait interval (ms) after task</p> <code>0</code> Source code in <code>botcity/core/bot.py</code> <pre><code>def delete(self, wait=0):\n\"\"\"\n    Press Delete key\n\n    Args:\n        wait (int, optional): Wait interval (ms) after task\n\n    \"\"\"\n    self._kb_controller.tap(Key.delete)\n    delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n    self.sleep(delay)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.display_size","title":"<code>display_size()</code>","text":"<p>Returns the display size in pixels.</p> <p>Returns:</p> Name Type Description <code>size</code> <code>Tuple</code> <p>The screen dimension (width and height) in pixels.</p> Source code in <code>botcity/core/bot.py</code> <pre><code>def display_size(self):\n\"\"\"\n    Returns the display size in pixels.\n\n    Returns:\n        size (Tuple): The screen dimension (width and height) in pixels.\n    \"\"\"\n    width, height = self._fix_display_size()\n    return width, height\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.double_click","title":"<code>double_click(wait_after=config.DEFAULT_SLEEP_AFTER_ACTION)</code>","text":"<p>Double Click on the last found element.</p> <p>Parameters:</p> Name Type Description Default <code>wait_after</code> <code>int</code> <p>Interval to wait after clicking on the element.</p> <code>config.DEFAULT_SLEEP_AFTER_ACTION</code> Source code in <code>botcity/core/bot.py</code> <pre><code>@only_if_element\ndef double_click(self, wait_after=config.DEFAULT_SLEEP_AFTER_ACTION):\n\"\"\"\n    Double Click on the last found element.\n\n    Args:\n        wait_after (int, optional): Interval to wait after clicking on the element.\n    \"\"\"\n    self.click(wait_after=wait_after, clicks=2)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.double_click_relative","title":"<code>double_click_relative(x, y, interval_between_clicks=0, wait_after=config.DEFAULT_SLEEP_AFTER_ACTION)</code>","text":"<p>Double Click Relative on the last found element.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>Horizontal offset</p> required <code>y</code> <code>int</code> <p>Vertical offset</p> required <code>interval_between_clicks</code> <code>int</code> <p>The interval between clicks in ms. Defaults to 0.</p> <code>0</code> <code>wait_after</code> <code>int</code> <p>Interval to wait after clicking on the element.</p> <code>config.DEFAULT_SLEEP_AFTER_ACTION</code> Source code in <code>botcity/core/bot.py</code> <pre><code>@only_if_element\ndef double_click_relative(self, x, y, interval_between_clicks=0, wait_after=config.DEFAULT_SLEEP_AFTER_ACTION):\n\"\"\"\n    Double Click Relative on the last found element.\n\n    Args:\n        x (int): Horizontal offset\n        y (int): Vertical offset\n        interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0.\n        wait_after (int, optional): Interval to wait after clicking on the element.\n\n    \"\"\"\n    self.click_relative(x, y, wait_after=wait_after, clicks=2, interval_between_clicks=interval_between_clicks)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.enter","title":"<code>enter(wait=0, presses=1)</code>","text":"<p>Press key Enter</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>int</code> <p>Wait interval (ms) after task</p> <code>0</code> <code>presses</code> <code>int</code> <p>Number of times to press the key. Defaults to 1.</p> <code>1</code> Source code in <code>botcity/core/bot.py</code> <pre><code>def enter(self, wait=0, presses=1):\n\"\"\"\n    Press key Enter\n\n    Args:\n        wait (int, optional): Wait interval (ms) after task\n        presses (int, optional): Number of times to press the key. Defaults to 1.\n\n    \"\"\"\n    delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n    for i in range(presses):\n        self._kb_controller.tap(Key.enter)\n        self.sleep(delay)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.execute","title":"<code>execute(file_path)</code>","text":"<p>Invoke the system handler to open the given file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>The path for the file to be executed</p> required Source code in <code>botcity/core/bot.py</code> <pre><code>def execute(self, file_path):\n\"\"\"\n    Invoke the system handler to open the given file.\n\n    Args:\n        file_path (str): The path for the file to be executed\n    \"\"\"\n    if platform.system() == \"Windows\":\n        os.startfile(file_path)\n    else:\n        subprocess.Popen(file_path.split(\" \"))\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.find","title":"<code>find(label, x=None, y=None, width=None, height=None, *, threshold=None, matching=0.9, waiting_time=10000, best=True, grayscale=False)</code>","text":"<p>Find an element defined by label on screen until a timeout happens.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The image identifier</p> required <code>x</code> <code>int</code> <p>Search region start position x. Defaults to 0.</p> <code>None</code> <code>y</code> <code>int</code> <p>Search region start position y. Defaults to 0.</p> <code>None</code> <code>width</code> <code>int</code> <p>Search region width. Defaults to screen width.</p> <code>None</code> <code>height</code> <code>int</code> <p>Search region height. Defaults to screen height.</p> <code>None</code> <code>threshold</code> <code>int</code> <p>The threshold to be applied when doing grayscale search. Defaults to None.</p> <code>None</code> <code>matching</code> <code>float</code> <p>The matching index ranging from 0 to 1. Defaults to 0.9.</p> <code>0.9</code> <code>waiting_time</code> <code>int</code> <p>Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s).</p> <code>10000</code> <code>best</code> <code>bool</code> <p>Whether or not to keep looking until the best matching is found. Defaults to True.</p> <code>True</code> <code>grayscale</code> <code>bool</code> <p>Whether or not to convert to grayscale before searching. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>element</code> <code>NamedTuple</code> <p>The element coordinates. None if not found.</p> Source code in <code>botcity/core/bot.py</code> <pre><code>def find(self, label, x=None, y=None, width=None, height=None, *, threshold=None,\n         matching=0.9, waiting_time=10000, best=True, grayscale=False):\n\"\"\"\n    Find an element defined by label on screen until a timeout happens.\n\n    Args:\n        label (str): The image identifier\n        x (int, optional): Search region start position x. Defaults to 0.\n        y (int, optional): Search region start position y. Defaults to 0.\n        width (int, optional): Search region width. Defaults to screen width.\n        height (int, optional): Search region height. Defaults to screen height.\n        threshold (int, optional): The threshold to be applied when doing grayscale search.\n            Defaults to None.\n        matching (float, optional): The matching index ranging from 0 to 1.\n            Defaults to 0.9.\n        waiting_time (int, optional): Maximum wait time (ms) to search for a hit.\n            Defaults to 10000ms (10s).\n        best (bool, optional): Whether or not to keep looking until the best matching is found.\n            Defaults to True.\n        grayscale (bool, optional): Whether or not to convert to grayscale before searching.\n            Defaults to False.\n\n    Returns:\n        element (NamedTuple): The element coordinates. None if not found.\n    \"\"\"\n    return self.find_until(label, x=x, y=y, width=width, height=height, threshold=threshold,\n                           matching=matching, waiting_time=waiting_time, best=best, grayscale=grayscale)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.find_all","title":"<code>find_all(label, x=None, y=None, width=None, height=None, *, threshold=None, matching=0.9, waiting_time=10000, grayscale=False)</code>","text":"<p>Find all elements defined by label on screen until a timeout happens.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The image identifier</p> required <code>x</code> <code>int</code> <p>Search region start position x. Defaults to 0.</p> <code>None</code> <code>y</code> <code>int</code> <p>Search region start position y. Defaults to 0.</p> <code>None</code> <code>width</code> <code>int</code> <p>Search region width. Defaults to screen width.</p> <code>None</code> <code>height</code> <code>int</code> <p>Search region height. Defaults to screen height.</p> <code>None</code> <code>threshold</code> <code>int</code> <p>The threshold to be applied when doing grayscale search. Defaults to None.</p> <code>None</code> <code>matching</code> <code>float</code> <p>The matching index ranging from 0 to 1. Defaults to 0.9.</p> <code>0.9</code> <code>waiting_time</code> <code>int</code> <p>Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s).</p> <code>10000</code> <code>grayscale</code> <code>bool</code> <p>Whether or not to convert to grayscale before searching. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>elements</code> <code>collections.Iterable[NamedTuple]</code> <p>A generator with all element coordinates fount. None if not found.</p> Source code in <code>botcity/core/bot.py</code> <pre><code>def find_all(self, label, x=None, y=None, width=None, height=None, *,\n             threshold=None, matching=0.9, waiting_time=10000, grayscale=False):\n\"\"\"\n    Find all elements defined by label on screen until a timeout happens.\n\n    Args:\n        label (str): The image identifier\n        x (int, optional): Search region start position x. Defaults to 0.\n        y (int, optional): Search region start position y. Defaults to 0.\n        width (int, optional): Search region width. Defaults to screen width.\n        height (int, optional): Search region height. Defaults to screen height.\n        threshold (int, optional): The threshold to be applied when doing grayscale search.\n            Defaults to None.\n        matching (float, optional): The matching index ranging from 0 to 1.\n            Defaults to 0.9.\n        waiting_time (int, optional): Maximum wait time (ms) to search for a hit.\n            Defaults to 10000ms (10s).\n        grayscale (bool, optional): Whether or not to convert to grayscale before searching.\n            Defaults to False.\n\n    Returns:\n        elements (collections.Iterable[NamedTuple]): A generator with all element coordinates fount.\n            None if not found.\n    \"\"\"\n    def deduplicate(elems):\n        def find_same(item, items):\n            x_start = item.left\n            x_end = item.left + item.width\n            y_start = item.top\n            y_end = item.top + item.height\n            similars = []\n            for itm in items:\n                if itm == item:\n                    continue\n                if (itm.left &gt;= x_start and itm.left &lt; x_end)\\\n                        and (itm.top &gt;= y_start and itm.top &lt; y_end):\n                    similars.append(itm)\n                    continue\n            return similars\n\n        index = 0\n        while True:\n            try:\n                dups = find_same(elems[index], elems[index:])\n                for d in dups:\n                    elems.remove(d)\n                index += 1\n            except IndexError:\n                break\n        return elems\n\n    self.state.element = None\n    screen_w, screen_h = self._fix_display_size()\n    x = x or 0\n    y = y or 0\n    w = width or screen_w\n    h = height or screen_h\n\n    region = (x, y, w, h)\n\n    element_path = self._search_image_file(label)\n    element_path = self._image_path_as_image(element_path)\n\n    if threshold:\n        # TODO: Figure out how we should do threshold\n        print('Threshold not yet supported')\n\n    start_time = time.time()\n\n    while True:\n        elapsed_time = (time.time() - start_time) * 1000\n        if elapsed_time &gt; waiting_time:\n            return None\n\n        haystack = self.get_screenshot()\n        eles = cv2find.locate_all_opencv(element_path, haystack_image=haystack,\n                                         region=region, confidence=matching, grayscale=grayscale)\n        if not eles:\n            continue\n        eles = deduplicate(list(eles))\n        for ele in eles:\n            if ele is not None:\n                ele = self._fix_retina_element(ele)\n                self.state.element = ele\n                yield ele\n        break\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.find_app_element","title":"<code>find_app_element(from_parent_window=None, waiting_time=10000, **selectors)</code>","text":"<p>Find a element of the currently connected application using the available selectors. You can pass the context window where the element is contained.</p> <p>Parameters:</p> Name Type Description Default <code>from_parent_window</code> <code>WindowSpecification</code> <p>The element's parent window.</p> <code>None</code> <code>waiting_time</code> <code>int</code> <p>Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s).</p> <code>10000</code> <code>**selectors</code> <p>Attributes that can be used to filter an element. See more details about the available selectors                .</p> <code>{}</code> <p>Returns     element (WindowSpecification): The element/control found.</p> Source code in <code>botcity/core/bot.py</code> <pre><code>@if_app_connected\ndef find_app_element(self, from_parent_window: 'WindowSpecification' = None,\n                     waiting_time=10000, **selectors) -&gt; 'WindowSpecification':\n\"\"\"\n    Find a element of the currently connected application using the available selectors.\n    You can pass the context window where the element is contained.\n\n    Args:\n        from_parent_window (WindowSpecification, optional): The element's parent window.\n        waiting_time (int, optional): Maximum wait time (ms) to search for a hit.\n            Defaults to 10000ms (10s).\n        **selectors: Attributes that can be used to filter an element.\n            [See more details about the available selectors\\\n            ](https://documentation.botcity.dev/frameworks/desktop/windows-apps/).\n\n    Returns\n        element (WindowSpecification): The element/control found.\n    \"\"\"\n    element = find_element(self.app, from_parent_window, waiting_time, **selectors)\n    return element\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.find_app_window","title":"<code>find_app_window(waiting_time=10000, **selectors)</code>","text":"<p>Find a window of the currently connected application using the available selectors.</p> <p>Parameters:</p> Name Type Description Default <code>waiting_time</code> <code>int</code> <p>Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s).</p> <code>10000</code> <code>**selectors</code> <p>Attributes that can be used to filter an element. See more details about the available selectors                .</p> <code>{}</code> <p>Returns     dialog (WindowSpecification): The window or control found.</p> Source code in <code>botcity/core/bot.py</code> <pre><code>@if_app_connected\ndef find_app_window(self, waiting_time=10000, **selectors) -&gt; 'WindowSpecification':\n\"\"\"\n    Find a window of the currently connected application using the available selectors.\n\n    Args:\n        waiting_time (int, optional): Maximum wait time (ms) to search for a hit.\n            Defaults to 10000ms (10s).\n        **selectors: Attributes that can be used to filter an element.\n            [See more details about the available selectors\\\n            ](https://documentation.botcity.dev/frameworks/desktop/windows-apps/).\n\n    Returns\n        dialog (WindowSpecification): The window or control found.\n    \"\"\"\n    dialog = find_window(self.app, waiting_time, **selectors)\n    return dialog\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.find_multiple","title":"<code>find_multiple(labels, x=None, y=None, width=None, height=None, *, threshold=None, matching=0.9, waiting_time=10000, best=True, grayscale=False)</code>","text":"<p>Find multiple elements defined by label on screen until a timeout happens.</p> <p>Parameters:</p> Name Type Description Default <code>labels</code> <code>list</code> <p>A list of image identifiers</p> required <code>x</code> <code>int</code> <p>Search region start position x. Defaults to 0.</p> <code>None</code> <code>y</code> <code>int</code> <p>Search region start position y. Defaults to 0.</p> <code>None</code> <code>width</code> <code>int</code> <p>Search region width. Defaults to screen width.</p> <code>None</code> <code>height</code> <code>int</code> <p>Search region height. Defaults to screen height.</p> <code>None</code> <code>threshold</code> <code>int</code> <p>The threshold to be applied when doing grayscale search. Defaults to None.</p> <code>None</code> <code>matching</code> <code>float</code> <p>The matching index ranging from 0 to 1. Defaults to 0.9.</p> <code>0.9</code> <code>waiting_time</code> <code>int</code> <p>Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s).</p> <code>10000</code> <code>best</code> <code>bool</code> <p>Whether or not to keep looking until the best matching is found. Defaults to True.</p> <code>True</code> <code>grayscale</code> <code>bool</code> <p>Whether or not to convert to grayscale before searching. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>results</code> <code>dict</code> <p>A dictionary in which the key is the label and value are the element coordinates in a NamedTuple.</p> Source code in <code>botcity/core/bot.py</code> <pre><code>def find_multiple(self, labels, x=None, y=None, width=None, height=None, *,\n                  threshold=None, matching=0.9, waiting_time=10000, best=True, grayscale=False):\n\"\"\"\n    Find multiple elements defined by label on screen until a timeout happens.\n\n    Args:\n        labels (list): A list of image identifiers\n        x (int, optional): Search region start position x. Defaults to 0.\n        y (int, optional): Search region start position y. Defaults to 0.\n        width (int, optional): Search region width. Defaults to screen width.\n        height (int, optional): Search region height. Defaults to screen height.\n        threshold (int, optional): The threshold to be applied when doing grayscale search.\n            Defaults to None.\n        matching (float, optional): The matching index ranging from 0 to 1.\n            Defaults to 0.9.\n        waiting_time (int, optional): Maximum wait time (ms) to search for a hit.\n            Defaults to 10000ms (10s).\n        best (bool, optional): Whether or not to keep looking until the best matching is found.\n            Defaults to True.\n        grayscale (bool, optional): Whether or not to convert to grayscale before searching.\n            Defaults to False.\n\n    Returns:\n        results (dict): A dictionary in which the key is the label and value are the element coordinates in a\n           NamedTuple.\n    \"\"\"\n\n    def _to_dict(lbs, elems):\n        return {k: v for k, v in zip(lbs, elems)}\n\n    screen_w, screen_h = self._fix_display_size()\n    x = x or 0\n    y = y or 0\n    w = width or screen_w\n    h = height or screen_h\n\n    region = (x, y, w, h)\n\n    results = [None] * len(labels)\n    paths = [self._search_image_file(la) for la in labels]\n    paths = [self._image_path_as_image(la) for la in paths]\n\n    if threshold:\n        # TODO: Figure out how we should do threshold\n        print('Threshold not yet supported')\n\n    if not best:\n        # TODO: Implement best=False.\n        print('Warning: Ignoring best=False for now. It will be supported in the future.')\n\n    start_time = time.time()\n    n_cpus = multiprocessing.cpu_count() - 1\n\n    while True:\n        elapsed_time = (time.time() - start_time) * 1000\n        if elapsed_time &gt; waiting_time:\n            return _to_dict(labels, results)\n\n        haystack = self.screenshot()\n        helper = functools.partial(self._find_multiple_helper, haystack, region, matching, grayscale)\n\n        with multiprocessing.Pool(processes=n_cpus) as pool:\n            results = pool.map(helper, paths)\n\n        results = [self._fix_retina_element(r) for r in results]\n        if None in results:\n            continue\n        else:\n            return _to_dict(labels, results)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.find_process","title":"<code>find_process(name=None, pid=None)</code>","text":"<p>Find a process by name or PID</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The process name.</p> <code>None</code> <code>pid</code> <code>str) or (int</code> <p>The PID (Process Identifier).</p> <code>None</code> Return <p>process (psutil.Process): A Process instance.</p> Source code in <code>botcity/core/bot.py</code> <pre><code>def find_process(self, name: str = None, pid: str = None) -&gt; List[Process]:\n\"\"\"\n    Find a process by name or PID\n\n    Args:\n        name (str): The process name.\n        pid (str) or (int): The PID (Process Identifier).\n\n    Return:\n        process (psutil.Process): A Process instance.\n    \"\"\"\n    for process in psutil.process_iter():\n        try:\n            if (name is not None and name in process.name()) or \\\n                    (pid is not None and process.pid == pid):\n                return process\n        except (psutil.NoSuchProcess, psutil.AccessDenied):\n            pass\n    return None\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.find_text","title":"<code>find_text(label, x=None, y=None, width=None, height=None, *, threshold=None, matching=0.9, waiting_time=10000, best=True)</code>","text":"<p>Find an element defined by label on screen until a timeout happens.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The image identifier</p> required <code>x</code> <code>int</code> <p>Search region start position x. Defaults to 0.</p> <code>None</code> <code>y</code> <code>int</code> <p>Search region start position y. Defaults to 0.</p> <code>None</code> <code>width</code> <code>int</code> <p>Search region width. Defaults to screen width.</p> <code>None</code> <code>height</code> <code>int</code> <p>Search region height. Defaults to screen height.</p> <code>None</code> <code>threshold</code> <code>int</code> <p>The threshold to be applied when doing grayscale search. Defaults to None.</p> <code>None</code> <code>matching</code> <code>float</code> <p>The matching index ranging from 0 to 1. Defaults to 0.9.</p> <code>0.9</code> <code>waiting_time</code> <code>int</code> <p>Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s).</p> <code>10000</code> <code>best</code> <code>bool</code> <p>Whether or not to keep looking until the best matching is found. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>element</code> <code>NamedTuple</code> <p>The element coordinates. None if not found.</p> Source code in <code>botcity/core/bot.py</code> <pre><code>def find_text(self, label, x=None, y=None, width=None, height=None, *, threshold=None, matching=0.9,\n              waiting_time=10000, best=True):\n\"\"\"\n    Find an element defined by label on screen until a timeout happens.\n\n    Args:\n        label (str): The image identifier\n        x (int, optional): Search region start position x. Defaults to 0.\n        y (int, optional): Search region start position y. Defaults to 0.\n        width (int, optional): Search region width. Defaults to screen width.\n        height (int, optional): Search region height. Defaults to screen height.\n        threshold (int, optional): The threshold to be applied when doing grayscale search.\n            Defaults to None.\n        matching (float, optional): The matching index ranging from 0 to 1.\n            Defaults to 0.9.\n        waiting_time (int, optional): Maximum wait time (ms) to search for a hit.\n            Defaults to 10000ms (10s).\n        best (bool, optional): Whether or not to keep looking until the best matching is found.\n            Defaults to True.\n\n    Returns:\n        element (NamedTuple): The element coordinates. None if not found.\n    \"\"\"\n    return self.find_until(label, x, y, width, height, threshold=threshold, matching=matching,\n                           waiting_time=waiting_time, best=best, grayscale=True)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.find_until","title":"<code>find_until(label, x=None, y=None, width=None, height=None, *, threshold=None, matching=0.9, waiting_time=10000, best=True, grayscale=False)</code>","text":"<p>Find an element defined by label on screen until a timeout happens.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The image identifier</p> required <code>x</code> <code>int</code> <p>Search region start position x. Defaults to 0.</p> <code>None</code> <code>y</code> <code>int</code> <p>Search region start position y. Defaults to 0.</p> <code>None</code> <code>width</code> <code>int</code> <p>Search region width. Defaults to screen width.</p> <code>None</code> <code>height</code> <code>int</code> <p>Search region height. Defaults to screen height.</p> <code>None</code> <code>threshold</code> <code>int</code> <p>The threshold to be applied when doing grayscale search. Defaults to None.</p> <code>None</code> <code>matching</code> <code>float</code> <p>The matching index ranging from 0 to 1. Defaults to 0.9.</p> <code>0.9</code> <code>waiting_time</code> <code>int</code> <p>Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s).</p> <code>10000</code> <code>best</code> <code>bool</code> <p>Whether or not to keep looking until the best matching is found. Defaults to True.</p> <code>True</code> <code>grayscale</code> <code>bool</code> <p>Whether or not to convert to grayscale before searching. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>element</code> <code>NamedTuple</code> <p>The element coordinates. None if not found.</p> Source code in <code>botcity/core/bot.py</code> <pre><code>def find_until(self, label, x=None, y=None, width=None, height=None, *,\n               threshold=None, matching=0.9, waiting_time=10000, best=True, grayscale=False):\n\"\"\"\n    Find an element defined by label on screen until a timeout happens.\n\n    Args:\n        label (str): The image identifier\n        x (int, optional): Search region start position x. Defaults to 0.\n        y (int, optional): Search region start position y. Defaults to 0.\n        width (int, optional): Search region width. Defaults to screen width.\n        height (int, optional): Search region height. Defaults to screen height.\n        threshold (int, optional): The threshold to be applied when doing grayscale search.\n            Defaults to None.\n        matching (float, optional): The matching index ranging from 0 to 1.\n            Defaults to 0.9.\n        waiting_time (int, optional): Maximum wait time (ms) to search for a hit.\n            Defaults to 10000ms (10s).\n        best (bool, optional): Whether or not to keep looking until the best matching is found.\n            Defaults to True.\n        grayscale (bool, optional): Whether or not to convert to grayscale before searching.\n            Defaults to False.\n\n    Returns:\n        element (NamedTuple): The element coordinates. None if not found.\n    \"\"\"\n    self.state.element = None\n    screen_w, screen_h = self._fix_display_size()\n    x = x or 0\n    y = y or 0\n    w = width or screen_w\n    h = height or screen_h\n\n    region = (x, y, w, h)\n\n    element_path = self._search_image_file(label)\n    element_path = self._image_path_as_image(element_path)\n\n    if threshold:\n        # TODO: Figure out how we should do threshold\n        print('Threshold not yet supported')\n\n    if not best:\n        # TODO: Implement best=False.\n        print('Warning: Ignoring best=False for now. It will be supported in the future.')\n\n    start_time = time.time()\n\n    while True:\n        elapsed_time = (time.time() - start_time) * 1000\n        if elapsed_time &gt; waiting_time:\n            return None\n\n        haystack = self.get_screenshot()\n        it = cv2find.locate_all_opencv(element_path, haystack_image=haystack,\n                                       region=region, confidence=matching, grayscale=grayscale)\n        try:\n            ele = next(it)\n        except StopIteration:\n            ele = None\n\n        if ele is not None:\n            ele = self._fix_retina_element(ele)\n            self.state.element = ele\n            return ele\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.get_clipboard","title":"<code>get_clipboard()</code>","text":"<p>Get the current content in the clipboard.</p> <p>Returns:</p> Name Type Description <code>text</code> <code>str</code> <p>Current clipboard content</p> Source code in <code>botcity/core/bot.py</code> <pre><code>def get_clipboard(self):\n\"\"\"\n    Get the current content in the clipboard.\n\n    Returns:\n        text (str): Current clipboard content\n    \"\"\"\n    return pyperclip.paste()\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.get_element_coords","title":"<code>get_element_coords(label, x=None, y=None, width=None, height=None, matching=0.9, best=True)</code>","text":"<p>Find an element defined by label on screen and returns its coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The image identifier</p> required <code>x</code> <code>int</code> <p>X (Left) coordinate of the search area.</p> <code>None</code> <code>y</code> <code>int</code> <p>Y (Top) coordinate of the search area.</p> <code>None</code> <code>width</code> <code>int</code> <p>Width of the search area.</p> <code>None</code> <code>height</code> <code>int</code> <p>Height of the search area.</p> <code>None</code> <code>matching</code> <code>float</code> <p>Minimum score to consider a match in the element image recognition process. Defaults to 0.9.</p> <code>0.9</code> <code>best</code> <code>bool</code> <p>Whether or not to search for the best value. If False the method returns on the first find. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>coords</code> <code>Tuple</code> <p>A tuple containing the x and y coordinates for the element.</p> Source code in <code>botcity/core/bot.py</code> <pre><code>def get_element_coords(self, label, x=None, y=None, width=None, height=None, matching=0.9, best=True):\n\"\"\"\n    Find an element defined by label on screen and returns its coordinates.\n\n    Args:\n        label (str): The image identifier\n        x (int, optional): X (Left) coordinate of the search area.\n        y (int, optional): Y (Top) coordinate of the search area.\n        width (int, optional): Width of the search area.\n        height (int, optional): Height of the search area.\n        matching (float, optional): Minimum score to consider a match in the element image recognition process.\n            Defaults to 0.9.\n        best (bool, optional): Whether or not to search for the best value. If False the method returns on\n            the first find. Defaults to True.\n\n    Returns:\n        coords (Tuple): A tuple containing the x and y coordinates for the element.\n    \"\"\"\n    self.state.element = None\n    screen_w, screen_h = self._fix_display_size()\n    x = x or 0\n    y = y or 0\n    width = width or screen_w\n    height = height or screen_h\n    region = (x, y, width, height)\n\n    if not best:\n        print('Warning: Ignoring best=False for now. It will be supported in the future.')\n\n    element_path = self._search_image_file(label)\n    element_path = self._image_path_as_image(element_path)\n\n    haystack = self.get_screenshot()\n    it = cv2find.locate_all_opencv(element_path, haystack_image=haystack,\n                                   region=region, confidence=matching, grayscale=False)\n    try:\n        ele = next(it)\n    except StopIteration:\n        ele = None\n\n    if ele is None:\n        return None, None\n    ele = self._fix_retina_element(ele)\n    self.state.element = ele\n    return ele.left, ele.top\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.get_element_coords_centered","title":"<code>get_element_coords_centered(label, x=None, y=None, width=None, height=None, matching=0.9, best=True)</code>","text":"<p>Find an element defined by label on screen and returns its centered coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The image identifier</p> required <code>x</code> <code>int</code> <p>X (Left) coordinate of the search area.</p> <code>None</code> <code>y</code> <code>int</code> <p>Y (Top) coordinate of the search area.</p> <code>None</code> <code>width</code> <code>int</code> <p>Width of the search area.</p> <code>None</code> <code>height</code> <code>int</code> <p>Height of the search area.</p> <code>None</code> <code>matching</code> <code>float</code> <p>Minimum score to consider a match in the element image recognition process. Defaults to 0.9.</p> <code>0.9</code> <code>best</code> <code>bool</code> <p>Whether or not to search for the best value. If False the method returns on the first find. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>coords</code> <code>Tuple</code> <p>A tuple containing the x and y coordinates for the center of the element.</p> Source code in <code>botcity/core/bot.py</code> <pre><code>def get_element_coords_centered(self, label, x=None, y=None, width=None, height=None,\n                                matching=0.9, best=True):\n\"\"\"\n    Find an element defined by label on screen and returns its centered coordinates.\n\n    Args:\n        label (str): The image identifier\n        x (int, optional): X (Left) coordinate of the search area.\n        y (int, optional): Y (Top) coordinate of the search area.\n        width (int, optional): Width of the search area.\n        height (int, optional): Height of the search area.\n        matching (float, optional): Minimum score to consider a match in the element image recognition process.\n            Defaults to 0.9.\n        best (bool, optional): Whether or not to search for the best value. If False the method returns on\n            the first find. Defaults to True.\n\n    Returns:\n        coords (Tuple): A tuple containing the x and y coordinates for the center of the element.\n    \"\"\"\n    self.get_element_coords(label, x, y, width, height, matching, best)\n    return self.state.center()\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.get_image_from_map","title":"<code>get_image_from_map(label)</code>","text":"<p>Return an image from teh state image map.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The image identifier</p> required <p>Returns:</p> Name Type Description <code>Image</code> <p>The Image object</p> Source code in <code>botcity/core/bot.py</code> <pre><code>def get_image_from_map(self, label):\n\"\"\"\n    Return an image from teh state image map.\n\n    Args:\n        label (str): The image identifier\n\n    Returns:\n        Image: The Image object\n    \"\"\"\n    path = self.state.map_images.get(label)\n    if not path:\n        raise KeyError('Invalid label for image map.')\n    img = Image.open(path)\n    return img\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.get_last_element","title":"<code>get_last_element()</code>","text":"<p>Return the last element found.</p> <p>Returns:</p> Name Type Description <code>element</code> <code>NamedTuple</code> <p>The element coordinates (left, top, width, height)</p> Source code in <code>botcity/core/bot.py</code> <pre><code>def get_last_element(self):\n\"\"\"\n    Return the last element found.\n\n    Returns:\n        element (NamedTuple): The element coordinates (left, top, width, height)\n    \"\"\"\n    return self.state.element\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.get_last_x","title":"<code>get_last_x()</code>","text":"<p>Get the last X position for the mouse.</p> <p>Returns:</p> Name Type Description <code>x</code> <code>int</code> <p>The last x position for the mouse.</p> Source code in <code>botcity/core/bot.py</code> <pre><code>def get_last_x(self):\n\"\"\"\n    Get the last X position for the mouse.\n\n    Returns:\n        x (int): The last x position for the mouse.\n    \"\"\"\n    return self._mouse_controller.position[0]\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.get_last_y","title":"<code>get_last_y()</code>","text":"<p>Get the last Y position for the mouse.</p> <p>Returns:</p> Name Type Description <code>y</code> <code>int</code> <p>The last y position for the mouse.</p> Source code in <code>botcity/core/bot.py</code> <pre><code>def get_last_y(self):\n\"\"\"\n    Get the last Y position for the mouse.\n\n    Returns:\n        y (int): The last y position for the mouse.\n    \"\"\"\n    return self._mouse_controller.position[1]\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.get_screenshot","title":"<code>get_screenshot(filepath=None, region=None)</code>","text":"<p>Capture a screenshot.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>The filepath in which to save the screenshot. Defaults to None.</p> <code>None</code> <code>region</code> <code>tuple</code> <p>Bounding box containing left, top, width and height to crop screenshot.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Image</code> <p>The screenshot Image object</p> Source code in <code>botcity/core/bot.py</code> <pre><code>def get_screenshot(self, filepath=None, region=None):\n\"\"\"\n    Capture a screenshot.\n\n    Args:\n        filepath (str, optional): The filepath in which to save the screenshot. Defaults to None.\n        region (tuple, optional): Bounding box containing left, top, width and height to crop screenshot.\n\n    Returns:\n        Image: The screenshot Image object\n    \"\"\"\n    return self.screenshot(filepath, region)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.hold_shift","title":"<code>hold_shift(wait=0)</code>","text":"<p>Hold key Shift</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>int</code> <p>Wait interval (ms) after task</p> <code>0</code> Source code in <code>botcity/core/bot.py</code> <pre><code>def hold_shift(self, wait=0):\n\"\"\"\n    Hold key Shift\n\n    Args:\n        wait (int, optional): Wait interval (ms) after task\n\n    \"\"\"\n    self._kb_controller.press(Key.shift)\n    self.sleep(wait)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.kb_type","title":"<code>kb_type(text, interval=0)</code>","text":"<p>Type a text char by char (individual key events).</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>text to be typed.</p> required <code>interval</code> <code>int</code> <p>interval (ms) between each key press. Defaults to 0</p> <code>0</code> Source code in <code>botcity/core/bot.py</code> <pre><code>def kb_type(self, text, interval=0):\n\"\"\"\n    Type a text char by char (individual key events).\n\n    Args:\n        text (str): text to be typed.\n        interval (int, optional): interval (ms) between each key press. Defaults to 0\n\n    \"\"\"\n    for char in text:\n        self._kb_controller.type(char)\n        self.sleep(interval)\n    self.sleep(config.DEFAULT_SLEEP_AFTER_ACTION)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.key_end","title":"<code>key_end(wait=0)</code>","text":"<p>Press key End</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>int</code> <p>Wait interval (ms) after task</p> <code>0</code> Source code in <code>botcity/core/bot.py</code> <pre><code>def key_end(self, wait=0):\n\"\"\"\n    Press key End\n\n    Args:\n        wait (int, optional): Wait interval (ms) after task\n\n    \"\"\"\n    self._kb_controller.tap(Key.end)\n    delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n    self.sleep(delay)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.key_enter","title":"<code>key_enter(wait=0)</code>","text":"<p>Press key Enter</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>int</code> <p>Wait interval (ms) after task</p> <code>0</code> Source code in <code>botcity/core/bot.py</code> <pre><code>def key_enter(self, wait=0):\n\"\"\"\n    Press key Enter\n\n    Args:\n        wait (int, optional): Wait interval (ms) after task\n\n    \"\"\"\n    self.enter(wait)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.key_esc","title":"<code>key_esc(wait=0)</code>","text":"<p>Press key Esc</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>int</code> <p>Wait interval (ms) after task</p> <code>0</code> Source code in <code>botcity/core/bot.py</code> <pre><code>def key_esc(self, wait=0):\n\"\"\"\n    Press key Esc\n\n    Args:\n        wait (int, optional): Wait interval (ms) after task\n\n    \"\"\"\n    self._kb_controller.tap(Key.esc)\n    delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n    self.sleep(delay)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.key_right","title":"<code>key_right(wait=0)</code>","text":"<p>Press key Right</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>int</code> <p>Wait interval (ms) after task</p> <code>0</code> Source code in <code>botcity/core/bot.py</code> <pre><code>def key_right(self, wait=0):\n\"\"\"\n    Press key Right\n\n    Args:\n        wait (int, optional): Wait interval (ms) after task\n\n    \"\"\"\n    self._kb_controller.tap(Key.right)\n    delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n    self.sleep(delay)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.maximize_window","title":"<code>maximize_window()</code>","text":"<p>Shortcut to maximize window on Windows OS.</p> Source code in <code>botcity/core/bot.py</code> <pre><code>def maximize_window(self):\n\"\"\"\n    Shortcut to maximize window on Windows OS.\n    \"\"\"\n    with self._kb_controller.pressed(Key.alt, Key.space):\n        self._kb_controller.tap('x')\n    self.sleep(config.DEFAULT_SLEEP_AFTER_ACTION)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.mouse_down","title":"<code>mouse_down(wait_after=config.DEFAULT_SLEEP_AFTER_ACTION, *, button='left')</code>","text":"<p>Holds down the requested mouse button.</p> <p>Parameters:</p> Name Type Description Default <code>wait_after</code> <code>int</code> <p>Interval to wait after clicking on the element.</p> <code>config.DEFAULT_SLEEP_AFTER_ACTION</code> <code>button</code> <code>str</code> <p>One of 'left', 'right', 'middle'. Defaults to 'left'</p> <code>'left'</code> Source code in <code>botcity/core/bot.py</code> <pre><code>def mouse_down(self, wait_after=config.DEFAULT_SLEEP_AFTER_ACTION, *, button='left'):\n\"\"\"\n    Holds down the requested mouse button.\n\n    Args:\n        wait_after (int, optional): Interval to wait after clicking on the element.\n        button (str, optional): One of 'left', 'right', 'middle'. Defaults to 'left'\n    \"\"\"\n    mouse_button = mouse_map.get(button, None)\n    self._mouse_controller.press(mouse_button)\n    self.sleep(wait_after)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.mouse_move","title":"<code>mouse_move(x, y)</code>","text":"<p>Move the mouse to the coordinate defined by x and y</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>The X coordinate</p> required <code>y</code> <code>int</code> <p>The Y coordinate</p> required Source code in <code>botcity/core/bot.py</code> <pre><code>def mouse_move(self, x, y):\n\"\"\"\n    Move the mouse to the coordinate defined by x and y\n\n    Args:\n        x (int): The X coordinate\n        y (int): The Y coordinate\n\n    \"\"\"\n    self._mouse_controller.position = (x, y)\n    self.sleep(config.DEFAULT_SLEEP_AFTER_ACTION)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.mouse_up","title":"<code>mouse_up(wait_after=config.DEFAULT_SLEEP_AFTER_ACTION, *, button='left')</code>","text":"<p>Releases the requested mouse button.</p> <p>Parameters:</p> Name Type Description Default <code>wait_after</code> <code>int</code> <p>Interval to wait after clicking on the element.</p> <code>config.DEFAULT_SLEEP_AFTER_ACTION</code> <code>button</code> <code>str</code> <p>One of 'left', 'right', 'middle'. Defaults to 'left'</p> <code>'left'</code> Source code in <code>botcity/core/bot.py</code> <pre><code>def mouse_up(self, wait_after=config.DEFAULT_SLEEP_AFTER_ACTION, *, button='left'):\n\"\"\"\n    Releases the requested mouse button.\n\n    Args:\n        wait_after (int, optional): Interval to wait after clicking on the element.\n        button (str, optional): One of 'left', 'right', 'middle'. Defaults to 'left'\n    \"\"\"\n    mouse_button = mouse_map.get(button, None)\n    self._mouse_controller.release(mouse_button)\n    self.sleep(wait_after)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.move","title":"<code>move()</code>","text":"<p>Move to the center position of last found item.</p> Source code in <code>botcity/core/bot.py</code> <pre><code>@only_if_element\ndef move(self):\n\"\"\"\n    Move to the center position of last found item.\n    \"\"\"\n    x, y = self.state.center()\n    self._mouse_controller.position = (x, y)\n    self.sleep(config.DEFAULT_SLEEP_AFTER_ACTION)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.move_random","title":"<code>move_random(range_x, range_y)</code>","text":"<p>Move randomly along the given x, y range.</p> <p>Parameters:</p> Name Type Description Default <code>range_x</code> <code>int</code> <p>Horizontal range</p> required <code>range_y</code> <code>int</code> <p>Vertical range</p> required Source code in <code>botcity/core/bot.py</code> <pre><code>def move_random(self, range_x, range_y):\n\"\"\"\n    Move randomly along the given x, y range.\n\n    Args:\n        range_x (int): Horizontal range\n        range_y (int): Vertical range\n\n    \"\"\"\n    x = int(random.random() * range_x)\n    y = int(random.random() * range_y)\n    self._mouse_controller.position = (x, y)\n    self.sleep(config.DEFAULT_SLEEP_AFTER_ACTION)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.move_relative","title":"<code>move_relative(x, y)</code>","text":"<p>Move the mouse relative to its current position.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>Horizontal offset</p> required <code>y</code> <code>int</code> <p>Vertical offset</p> required Source code in <code>botcity/core/bot.py</code> <pre><code>def move_relative(self, x, y):\n\"\"\"\n    Move the mouse relative to its current position.\n\n    Args:\n        x (int): Horizontal offset\n        y (int): Vertical offset\n\n    \"\"\"\n    x = self.get_last_x() + x\n    y = self.get_last_y() + y\n    self._mouse_controller.position = (x, y)\n    self.sleep(config.DEFAULT_SLEEP_AFTER_ACTION)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.page_down","title":"<code>page_down(wait=0)</code>","text":"<p>Press Page Down key</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>int</code> <p>Wait interval (ms) after task</p> <code>0</code> Source code in <code>botcity/core/bot.py</code> <pre><code>def page_down(self, wait=0):\n\"\"\"\n    Press Page Down key\n\n    Args:\n        wait (int, optional): Wait interval (ms) after task\n\n    \"\"\"\n    self._kb_controller.tap(Key.page_down)\n    delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n    self.sleep(delay)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.page_up","title":"<code>page_up(wait=0)</code>","text":"<p>Press Page Up key</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>int</code> <p>Wait interval (ms) after task</p> <code>0</code> Source code in <code>botcity/core/bot.py</code> <pre><code>def page_up(self, wait=0):\n\"\"\"\n    Press Page Up key\n\n    Args:\n        wait (int, optional): Wait interval (ms) after task\n\n    \"\"\"\n    self._kb_controller.tap(Key.page_up)\n    delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n    self.sleep(delay)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.paste","title":"<code>paste(text=None, wait=0)</code>","text":"<p>Paste content from the clipboard.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text to be pasted. Defaults to None</p> <code>None</code> <code>wait</code> <code>int</code> <p>Wait interval (ms) after task</p> <code>0</code> Source code in <code>botcity/core/bot.py</code> <pre><code>def paste(self, text=None, wait=0):\n\"\"\"\n    Paste content from the clipboard.\n\n    Args:\n        text (str, optional): The text to be pasted. Defaults to None\n        wait (int, optional): Wait interval (ms) after task\n    \"\"\"\n    if text:\n        pyperclip.copy(text)\n    self.control_v()\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.release_shift","title":"<code>release_shift()</code>","text":"<p>Release key Shift. This method needs to be invoked after holding Shift or similar.</p> Source code in <code>botcity/core/bot.py</code> <pre><code>def release_shift(self):\n\"\"\"\n    Release key Shift.\n    This method needs to be invoked after holding Shift or similar.\n    \"\"\"\n    self._kb_controller.release(Key.shift)\n    self.sleep(config.DEFAULT_SLEEP_AFTER_ACTION)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.right_click","title":"<code>right_click(wait_after=config.DEFAULT_SLEEP_AFTER_ACTION, *, clicks=1, interval_between_clicks=0)</code>","text":"<p>Right click on the last found element.</p> <p>Parameters:</p> Name Type Description Default <code>wait_after</code> <code>int</code> <p>Interval to wait after clicking on the element.</p> <code>config.DEFAULT_SLEEP_AFTER_ACTION</code> <code>clicks</code> <code>int</code> <p>Number of times to click. Defaults to 1.</p> <code>1</code> <code>interval_between_clicks</code> <code>int</code> <p>The interval between clicks in ms. Defaults to 0.</p> <code>0</code> Source code in <code>botcity/core/bot.py</code> <pre><code>@only_if_element\ndef right_click(self, wait_after=config.DEFAULT_SLEEP_AFTER_ACTION, *,\n                clicks=1, interval_between_clicks=0):\n\"\"\"\n    Right click on the last found element.\n\n    Args:\n        wait_after (int, optional): Interval to wait after clicking on the element.\n        clicks (int, optional): Number of times to click. Defaults to 1.\n        interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0.\n    \"\"\"\n    x, y = self.state.center()\n    _mouse_click(self._mouse_controller, x, y, clicks, interval_between_clicks, button='right')\n    self.sleep(wait_after)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.right_click_at","title":"<code>right_click_at(x, y)</code>","text":"<p>Right click at the coordinate defined by x and y</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>The X coordinate</p> required <code>y</code> <code>int</code> <p>The Y coordinate</p> required Source code in <code>botcity/core/bot.py</code> <pre><code>def right_click_at(self, x, y):\n\"\"\"\n    Right click at the coordinate defined by x and y\n\n    Args:\n        x (int): The X coordinate\n        y (int): The Y coordinate\n    \"\"\"\n    _mouse_click(self._mouse_controller, x, y, button='right')\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.right_click_relative","title":"<code>right_click_relative(x, y, interval_between_clicks=0, wait_after=config.DEFAULT_SLEEP_AFTER_ACTION)</code>","text":"<p>Right Click Relative on the last found element.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>Horizontal offset</p> required <code>y</code> <code>int</code> <p>Vertical offset</p> required <code>interval_between_clicks</code> <code>int</code> <p>The interval between clicks in ms. Defaults to 0.</p> <code>0</code> <code>wait_after</code> <code>int</code> <p>Interval to wait after clicking on the element.</p> <code>config.DEFAULT_SLEEP_AFTER_ACTION</code> Source code in <code>botcity/core/bot.py</code> <pre><code>@only_if_element\ndef right_click_relative(self, x, y, interval_between_clicks=0, wait_after=config.DEFAULT_SLEEP_AFTER_ACTION):\n\"\"\"\n    Right Click Relative on the last found element.\n\n    Args:\n        x (int): Horizontal offset\n        y (int): Vertical offset\n        interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0.\n        wait_after (int, optional): Interval to wait after clicking on the element.\n    \"\"\"\n    self.click_relative(x, y, wait_after=wait_after, clicks=1, interval_between_clicks=interval_between_clicks,\n                        button='right')\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.save_screenshot","title":"<code>save_screenshot(path)</code>","text":"<p>Saves a screenshot in a given path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The filepath in which to save the screenshot</p> required Source code in <code>botcity/core/bot.py</code> <pre><code>def save_screenshot(self, path):\n\"\"\"\n    Saves a screenshot in a given path.\n\n    Args:\n        path (str): The filepath in which to save the screenshot\n\n    \"\"\"\n    self.screenshot(path)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.screen_cut","title":"<code>screen_cut(x, y, width=None, height=None)</code>","text":"<p>Capture a screenshot from a region of the screen.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>region start position x</p> required <code>y</code> <code>int</code> <p>region start position y</p> required <code>width</code> <code>int</code> <p>region width</p> <code>None</code> <code>height</code> <code>int</code> <p>region height</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Image</code> <p>The screenshot Image object</p> Source code in <code>botcity/core/bot.py</code> <pre><code>def screen_cut(self, x, y, width=None, height=None):\n\"\"\"\n    Capture a screenshot from a region of the screen.\n\n    Args:\n        x (int): region start position x\n        y (int): region start position y\n        width (int): region width\n        height (int): region height\n\n    Returns:\n        Image: The screenshot Image object\n    \"\"\"\n    screen_w, screen_h = self._fix_display_size()\n    x = x or 0\n    y = y or 0\n    width = width or screen_w\n    height = height or screen_h\n    img = self.screenshot(region=(x, y, width, height))\n    return img\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.screenshot","title":"<code>screenshot(filepath=None, region=None)</code>","text":"<p>Capture a screenshot.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>The filepath in which to save the screenshot. Defaults to None.</p> <code>None</code> <code>region</code> <code>tuple</code> <p>Bounding box containing left, top, width and height to crop screenshot.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Image</code> <p>The screenshot Image object</p> Source code in <code>botcity/core/bot.py</code> <pre><code>def screenshot(self, filepath=None, region=None):\n\"\"\"\n    Capture a screenshot.\n\n    Args:\n        filepath (str, optional): The filepath in which to save the screenshot. Defaults to None.\n        region (tuple, optional): Bounding box containing left, top, width and height to crop screenshot.\n\n    Returns:\n        Image: The screenshot Image object\n    \"\"\"\n    img = ImageGrab.grab(bbox=region)\n    if filepath:\n        img.save(filepath)\n    return img\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.scroll_down","title":"<code>scroll_down(clicks)</code>","text":"<p>Scroll Down n clicks</p> <p>Parameters:</p> Name Type Description Default <code>clicks</code> <code>int</code> <p>Number of times to scroll down.</p> required Source code in <code>botcity/core/bot.py</code> <pre><code>def scroll_down(self, clicks):\n\"\"\"\n    Scroll Down n clicks\n\n    Args:\n        clicks (int): Number of times to scroll down.\n    \"\"\"\n    self._mouse_controller.scroll(0, -1 * clicks)\n    self.sleep(config.DEFAULT_SLEEP_AFTER_ACTION)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.scroll_up","title":"<code>scroll_up(clicks)</code>","text":"<p>Scroll Up n clicks</p> <p>Parameters:</p> Name Type Description Default <code>clicks</code> <code>int</code> <p>Number of times to scroll up.</p> required Source code in <code>botcity/core/bot.py</code> <pre><code>def scroll_up(self, clicks):\n\"\"\"\n    Scroll Up n clicks\n\n    Args:\n        clicks (int): Number of times to scroll up.\n    \"\"\"\n    self._mouse_controller.scroll(0, clicks)\n    self.sleep(config.DEFAULT_SLEEP_AFTER_ACTION)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.shift_tab","title":"<code>shift_tab(wait=0)</code>","text":"<p>Press keys Shift+Tab</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>int</code> <p>Wait interval (ms) after task</p> <code>0</code> Source code in <code>botcity/core/bot.py</code> <pre><code>def shift_tab(self, wait=0):\n\"\"\"\n    Press keys Shift+Tab\n\n    Args:\n        wait (int, optional): Wait interval (ms) after task\n\n    \"\"\"\n    with self._kb_controller.pressed(Key.shift):\n        self._kb_controller.tap(Key.tab)\n    delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n    self.sleep(delay)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.sleep","title":"<code>sleep(interval)</code>","text":"<p>Wait / Sleep for a given interval.</p> <p>Parameters:</p> Name Type Description Default <code>interval</code> <code>int</code> <p>Interval in milliseconds</p> required Source code in <code>botcity/core/bot.py</code> <pre><code>def sleep(self, interval):\n\"\"\"\n    Wait / Sleep for a given interval.\n\n    Args:\n        interval (int): Interval in milliseconds\n\n    \"\"\"\n    self.wait(interval)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.space","title":"<code>space(wait=0)</code>","text":"<p>Press Space key</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>int</code> <p>Wait interval (ms) after task</p> <code>0</code> Source code in <code>botcity/core/bot.py</code> <pre><code>def space(self, wait=0):\n\"\"\"\n    Press Space key\n\n    Args:\n        wait (int, optional): Wait interval (ms) after task\n\n    \"\"\"\n    self._kb_controller.tap(Key.space)\n    delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n    self.sleep(delay)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.tab","title":"<code>tab(wait=0, presses=1)</code>","text":"<p>Press key Tab</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>int</code> <p>Wait interval (ms) after task</p> <code>0</code> <code>presses</code> <code>int</code> <p>Number of times to press the key. Defaults to 1.</p> <code>1</code> Source code in <code>botcity/core/bot.py</code> <pre><code>def tab(self, wait=0, presses=1):\n\"\"\"\n    Press key Tab\n\n    Args:\n        wait (int, optional): Wait interval (ms) after task\n        presses (int, optional): Number of times to press the key. Defaults to 1.\n\n    \"\"\"\n    delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n    for i in range(presses):\n        self._kb_controller.tap(Key.tab)\n        self.sleep(delay)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.terminate_process","title":"<code>terminate_process(process)</code>","text":"<p>Terminate the process via the received Process object.</p> <p>Parameters:</p> Name Type Description Default <code>process</code> <code>psutil.Process</code> <p>The process to terminate.</p> required Source code in <code>botcity/core/bot.py</code> <pre><code>def terminate_process(self, process: Process):\n\"\"\"\n    Terminate the process via the received Process object.\n\n    Args:\n        process (psutil.Process): The process to terminate.\n    \"\"\"\n    process.terminate()\n    process.wait(10)\n    if process.is_running():\n        raise Exception(\"Terminate process failed\")\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.triple_click","title":"<code>triple_click(wait_after=config.DEFAULT_SLEEP_AFTER_ACTION)</code>","text":"<p>Triple Click on the last found element.</p> <p>Parameters:</p> Name Type Description Default <code>wait_after</code> <code>int</code> <p>Interval to wait after clicking on the element.</p> <code>config.DEFAULT_SLEEP_AFTER_ACTION</code> Source code in <code>botcity/core/bot.py</code> <pre><code>@only_if_element\ndef triple_click(self, wait_after=config.DEFAULT_SLEEP_AFTER_ACTION):\n\"\"\"\n    Triple Click on the last found element.\n\n    Args:\n        wait_after (int, optional): Interval to wait after clicking on the element.\n    \"\"\"\n    self.click(wait_after=wait_after, clicks=3)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.triple_click_relative","title":"<code>triple_click_relative(x, y, interval_between_clicks=0, wait_after=config.DEFAULT_SLEEP_AFTER_ACTION)</code>","text":"<p>Triple Click Relative on the last found element.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>Horizontal offset</p> required <code>y</code> <code>int</code> <p>Vertical offset</p> required <code>interval_between_clicks</code> <code>int</code> <p>The interval between clicks in ms. Defaults to 0.</p> <code>0</code> <code>wait_after</code> <code>int</code> <p>Interval to wait after clicking on the element.</p> <code>config.DEFAULT_SLEEP_AFTER_ACTION</code> Source code in <code>botcity/core/bot.py</code> <pre><code>@only_if_element\ndef triple_click_relative(self, x, y, interval_between_clicks=0, wait_after=config.DEFAULT_SLEEP_AFTER_ACTION):\n\"\"\"\n    Triple Click Relative on the last found element.\n\n    Args:\n        x (int): Horizontal offset\n        y (int): Vertical offset\n        interval_between_clicks (int, optional): The interval between clicks in ms. Defaults to 0.\n        wait_after (int, optional): Interval to wait after clicking on the element.\n\n    \"\"\"\n    self.click_relative(x, y, wait_after=wait_after, clicks=3, interval_between_clicks=interval_between_clicks)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.type_down","title":"<code>type_down(wait=0)</code>","text":"<p>Press Down key</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>int</code> <p>Wait interval (ms) after task</p> <code>0</code> Source code in <code>botcity/core/bot.py</code> <pre><code>def type_down(self, wait=0):\n\"\"\"\n    Press Down key\n\n    Args:\n        wait (int, optional): Wait interval (ms) after task\n\n    \"\"\"\n    self._kb_controller.tap(Key.down)\n    delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n    self.sleep(delay)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.type_key","title":"<code>type_key(text, interval=0)</code>","text":"<p>Type a text char by char (individual key events).</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>text to be typed.</p> required <code>interval</code> <code>int</code> <p>interval (ms) between each key press. Defaults to 0</p> <code>0</code> Source code in <code>botcity/core/bot.py</code> <pre><code>def type_key(self, text, interval=0):\n\"\"\"\n    Type a text char by char (individual key events).\n\n    Args:\n        text (str): text to be typed.\n        interval (int, optional): interval (ms) between each key press. Defaults to 0\n\n    \"\"\"\n    self.kb_type(text=text, interval=interval)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.type_keys","title":"<code>type_keys(keys)</code>","text":"<p>Press a sequence of keys. Hold the keys in the specific order and releases them.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>list</code> <p>List of keys to be pressed</p> required Source code in <code>botcity/core/bot.py</code> <pre><code>def type_keys(self, keys):\n\"\"\"\n    Press a sequence of keys. Hold the keys in the specific order and releases them.\n\n    Args:\n        keys (list): List of keys to be pressed\n    \"\"\"\n    self.type_keys_with_interval(100, keys)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.type_keys_with_interval","title":"<code>type_keys_with_interval(interval, keys)</code>","text":"<p>Press a sequence of keys. Hold the keys in the specific order and releases them.</p> <p>Parameters:</p> Name Type Description Default <code>interval</code> <code>int</code> <p>Interval (ms) in which to press and release keys</p> required <code>keys</code> <code>list</code> <p>List of keys to be pressed</p> required Source code in <code>botcity/core/bot.py</code> <pre><code>def type_keys_with_interval(self, interval, keys):\n\"\"\"\n    Press a sequence of keys. Hold the keys in the specific order and releases them.\n\n    Args:\n        interval (int): Interval (ms) in which to press and release keys\n        keys (list): List of keys to be pressed\n    \"\"\"\n    formatted_keys = []\n    for key in keys:\n        if len(key) &lt;= 1:\n            formatted_keys.append(key)\n            continue\n        key = key.lower()\n        key_value = keys_map.get(key, None)\n        if key_value:\n            formatted_keys.append(key_value)\n        elif key in Key._member_names_:\n            key_value = Key[key]\n            formatted_keys.append(key_value)\n\n    for key in formatted_keys:\n        self._kb_controller.press(key)\n        self.sleep(interval)\n    for key in reversed(formatted_keys):\n        self._kb_controller.release(key)\n        self.sleep(interval)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.type_left","title":"<code>type_left(wait=0)</code>","text":"<p>Press Left key</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>int</code> <p>Wait interval (ms) after task</p> <code>0</code> Source code in <code>botcity/core/bot.py</code> <pre><code>def type_left(self, wait=0):\n\"\"\"\n    Press Left key\n\n    Args:\n        wait (int, optional): Wait interval (ms) after task\n\n    \"\"\"\n    self._kb_controller.tap(Key.left)\n    delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n    self.sleep(delay)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.type_right","title":"<code>type_right(wait=0)</code>","text":"<p>Press Right key</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>int</code> <p>Wait interval (ms) after task</p> <code>0</code> Source code in <code>botcity/core/bot.py</code> <pre><code>def type_right(self, wait=0):\n\"\"\"\n    Press Right key\n\n    Args:\n        wait (int, optional): Wait interval (ms) after task\n\n    \"\"\"\n    self._kb_controller.tap(Key.right)\n    delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n    self.sleep(delay)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.type_up","title":"<code>type_up(wait=0)</code>","text":"<p>Press Up key</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>int</code> <p>Wait interval (ms) after task</p> <code>0</code> Source code in <code>botcity/core/bot.py</code> <pre><code>def type_up(self, wait=0):\n\"\"\"\n    Press Up key\n\n    Args:\n        wait (int, optional): Wait interval (ms) after task\n\n    \"\"\"\n    self._kb_controller.tap(Key.up)\n    delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n    self.sleep(delay)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.type_windows","title":"<code>type_windows(wait=0)</code>","text":"<p>Press Win logo key</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>int</code> <p>Wait interval (ms) after task</p> <code>0</code> Source code in <code>botcity/core/bot.py</code> <pre><code>def type_windows(self, wait=0):\n\"\"\"\n    Press Win logo key\n\n    Args:\n        wait (int, optional): Wait interval (ms) after task\n\n    \"\"\"\n    self._kb_controller.tap(Key.cmd)\n    delay = max(0, wait or config.DEFAULT_SLEEP_AFTER_ACTION)\n    self.sleep(delay)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.wait","title":"<code>wait(interval)</code>","text":"<p>Wait / Sleep for a given interval.</p> <p>Parameters:</p> Name Type Description Default <code>interval</code> <code>int</code> <p>Interval in milliseconds</p> required Source code in <code>botcity/core/bot.py</code> <pre><code>def wait(self, interval):\n\"\"\"\n    Wait / Sleep for a given interval.\n\n    Args:\n        interval (int): Interval in milliseconds\n\n    \"\"\"\n    time.sleep(interval / 1000.0)\n</code></pre>"},{"location":"bot/#botcity.core.bot.DesktopBot.wait_for_file","title":"<code>wait_for_file(path, timeout=10000)</code>","text":"<p>Invoke the system handler to open the given file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path for the file to be executed</p> required <code>timeout</code> <code>int</code> <p>Maximum wait time (ms) to search for a hit. Defaults to 10000ms (10s).</p> <code>10000</code> <p>Returns     status (bool): Whether or not the file was available before the timeout</p> Source code in <code>botcity/core/bot.py</code> <pre><code>def wait_for_file(self, path, timeout=10000):\n\"\"\"\n    Invoke the system handler to open the given file.\n\n    Args:\n        path (str): The path for the file to be executed\n        timeout (int, optional): Maximum wait time (ms) to search for a hit.\n            Defaults to 10000ms (10s).\n\n    Returns\n        status (bool): Whether or not the file was available before the timeout\n    \"\"\"\n    start_time = time.time()\n\n    while True:\n        elapsed_time = (time.time() - start_time) * 1000\n        if elapsed_time &gt; timeout:\n            return False\n        if os.path.isfile(path) and os.access(path, os.R_OK):\n            return True\n        self.sleep(config.DEFAULT_SLEEP_AFTER_ACTION)\n</code></pre>"},{"location":"intro/","title":"Getting Started","text":"<p>After you installed this package, the next step is to import the package into your code and start using the functions to build your RPA pipeline.</p> <pre><code>from botcity.core import DesktopBot\n</code></pre> <p>As a demonstration of the library, let's build a simple bot together that will open BotCity's website in your browser.</p>"},{"location":"intro/#opening-the-browser","title":"Opening the browser","text":"<p>To open the browser you can leverage the <code>browser</code> method which takes as argument a URL.</p> <pre><code>bot = DesktopBot()\nbot.browser(\"https://www.botcity.dev/en\")\n</code></pre> <p>You can use this framework in two ways:</p> <ul> <li>Scripting using the functions</li> <li>Creating a Bot class</li> </ul> <p>The second method is the best if you plan to integrate your bot with the BotCity Maestro SDK. The template project uses the Bot class and the examples cover both approaches.</p>"},{"location":"intro/#template-project","title":"Template Project","text":"<p>We created a template project using Cookiecutter to help you create new bots using BotCity's Python Framework.</p> <p>Take a look into the template project website for more information on how to use it and get started.</p>"},{"location":"intro/#next-steps","title":"Next Steps","text":"<p>Check our examples and experiment with the API. Let us know where it can be improved.</p> <p>Have fun automating!</p>"}]}